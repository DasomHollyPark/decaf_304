Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    MINUS
    DIVIDED_BY
    PLUS
    TIMES

Grammar

Rule 0     S' -> empty
Rule 1     empty -> <empty>
Rule 2     start -> program
Rule 3     program -> class_decl_star
Rule 4     class_decl_star -> empty
Rule 5     class_decl_star -> class_decl class_decl_star
Rule 6     class_decl -> CLASS ID extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE
Rule 7     extends_opt -> empty
Rule 8     extends_opt -> extends
Rule 9     extends -> EXTENDS ID
Rule 10    class_body_decl_plus -> class_body_decl class_body_decl_plus
Rule 11    class_body_decl_plus -> class_body_decl
Rule 12    class_body_decl -> field_decl
Rule 13    class_body_decl -> method_decl
Rule 14    class_body_decl -> constructor_decl
Rule 15    field_decl -> modifier var_decl
Rule 16    modifier -> empty
Rule 17    modifier -> PUBLIC
Rule 18    modifier -> PRIVATE
Rule 19    modifier -> PUBLIC STATIC
Rule 20    modifier -> PRIVATE STATIC
Rule 21    modifier -> STATIC
Rule 22    var_decl -> type variables SEMICOLON
Rule 23    type -> INT
Rule 24    type -> FLOAT
Rule 25    type -> BOOLEAN
Rule 26    type -> ID
Rule 27    variables -> variable more_variables
Rule 28    more_variables -> empty
Rule 29    more_variables -> COMMA variable more_variables
Rule 30    variable -> ID array_dim_star
Rule 31    array_dim_star -> empty
Rule 32    array_dim_star -> array_dim array_dim_star
Rule 33    array_dim -> LEFT_BRACKET RIGHT_BRACKET
Rule 34    method_decl -> modifier type_or_void ID LEFT_PAR formals_opt RIGHT_PAR block
Rule 35    type_or_void -> type
Rule 36    type_or_void -> VOID
Rule 37    constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block
Rule 38    formals_opt -> empty
Rule 39    formals_opt -> formals
Rule 40    formals -> formal_param more_formals
Rule 41    more_formals -> empty
Rule 42    more_formals -> COMMA formal_param more_formals
Rule 43    formal_param -> type variable
Rule 44    block -> LEFT_BRACE stmt_star RIGHT_BRACE
Rule 45    stmt_star -> empty
Rule 46    stmt_star -> stmt stmt_star
Rule 47    stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt
Rule 48    stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt
Rule 49    stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
Rule 50    stmt -> RETURN expr_opt SEMICOLON
Rule 51    stmt -> stmt_expr SEMICOLON
Rule 52    stmt -> BREAK SEMICOLON
Rule 53    stmt -> CONTINUE SEMICOLON
Rule 54    stmt -> block
Rule 55    stmt -> var_decl
Rule 56    stmt -> SEMICOLON
Rule 57    else_opt -> empty
Rule 58    else_opt -> ELSE stmt
Rule 59    literal -> INT_CONST
Rule 60    literal -> FLOAT_CONST
Rule 61    literal -> STRING_CONST
Rule 62    literal -> NULL
Rule 63    literal -> TRUE
Rule 64    literal -> FALSE
Rule 65    primary -> literal
Rule 66    primary -> THIS
Rule 67    primary -> SUPER
Rule 68    primary -> LEFT_PAR expr RIGHT_PAR
Rule 69    primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR
Rule 70    primary -> lhs
Rule 71    primary -> method_invocation
Rule 72    arguments_opt -> empty
Rule 73    arguments_opt -> arguments
Rule 74    arguments -> expr more_expr
Rule 75    more_expr -> empty
Rule 76    more_expr -> COMMA expr more_expr
Rule 77    lhs -> field_access
Rule 78    lhs -> array_access
Rule 79    field_access -> primary DOT ID
Rule 80    field_access -> ID
Rule 81    array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET
Rule 82    method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR
Rule 83    expr -> primary
Rule 84    expr -> assign
Rule 85    expr -> new_array
Rule 86    expr -> expr ARITH_OP expr
Rule 87    expr -> expr BOOL_OP expr
Rule 88    expr -> UNARY_OP expr
Rule 89    assign -> lhs EQUALS expr
Rule 90    assign -> lhs PLUS_PLUS
Rule 91    assign -> PLUS_PLUS lhs
Rule 92    assign -> lhs MINUS_MINUS
Rule 93    assign -> MINUS_MINUS lhs
Rule 94    new_array -> NEW type array_expr_plus
Rule 95    array_expr_plus -> array_expr array_expr_plus
Rule 96    array_expr_plus -> array_expr
Rule 97    array_expr -> LEFT_BRACKET expr RIGHT_BRACKET
Rule 98    array_empty_star -> empty
Rule 99    array_empty_star -> array_empty array_empty_star
Rule 100   array_empty -> LEFT_BRACKET RIGHT_BRACKET
Rule 101   stmt_expr -> assign
Rule 102   stmt_expr -> method_invocation
Rule 103   stmt_expr_opt -> empty
Rule 104   stmt_expr_opt -> stmt_expr
Rule 105   expr_opt -> empty
Rule 106   expr_opt -> expr

Terminals, with rules where they appear

ARITH_OP             : 86
BOOLEAN              : 25
BOOL_OP              : 87
BREAK                : 52
CLASS                : 6
COMMA                : 29 42 76
CONTINUE             : 53
DIVIDED_BY           : 
DO                   : 
DOT                  : 79
ELSE                 : 58
EQUALS               : 89
EXTENDS              : 9
FALSE                : 64
FLOAT                : 24
FLOAT_CONST          : 60
FOR                  : 49
ID                   : 6 9 26 30 34 37 69 79 80
IF                   : 47
INT                  : 23
INT_CONST            : 59
LEFT_BRACE           : 6 44
LEFT_BRACKET         : 33 81 97 100
LEFT_PAR             : 34 37 47 48 49 68 69 82
MINUS                : 
MINUS_MINUS          : 92 93
NEW                  : 69 94
NULL                 : 62
PLUS                 : 
PLUS_PLUS            : 90 91
PRIVATE              : 18 20
PUBLIC               : 17 19
RETURN               : 50
RIGHT_BRACE          : 6 44
RIGHT_BRACKET        : 33 81 97 100
RIGHT_PAR            : 34 37 47 48 49 68 69 82
SEMICOLON            : 22 49 49 50 51 52 53 56
STATIC               : 19 20 21
STRING_CONST         : 61
SUPER                : 67
THIS                 : 66
TIMES                : 
TRUE                 : 63
UNARY_OP             : 88
VOID                 : 36
WHILE                : 48
error                : 

Nonterminals, with rules where they appear

arguments            : 73
arguments_opt        : 69 82
array_access         : 78
array_dim            : 32
array_dim_star       : 30 32
array_empty          : 99
array_empty_star     : 99
array_expr           : 95 96
array_expr_plus      : 94 95
assign               : 84 101
block                : 34 37 54
class_body_decl      : 10 11
class_body_decl_plus : 6 10
class_decl           : 5
class_decl_star      : 3 5
constructor_decl     : 14
else_opt             : 47
empty                : 4 7 16 28 31 38 41 45 57 72 75 98 103 105 0
expr                 : 47 48 68 74 76 81 86 86 87 87 88 89 97 106
expr_opt             : 49 50
extends              : 6 8
extends_opt          : 
field_access         : 77 82
field_decl           : 12
formal_param         : 40 42
formals              : 39
formals_opt          : 34 37
lhs                  : 70 89 90 91 92 93
literal              : 65
method_decl          : 13
method_invocation    : 71 102
modifier             : 15 34 37
more_expr            : 74 76
more_formals         : 40 42
more_variables       : 27 29
new_array            : 85
primary              : 79 81 83
program              : 2
start                : 
stmt                 : 46 47 48 49 58
stmt_expr            : 51 104
stmt_expr_opt        : 49 49
stmt_star            : 44 46
type                 : 22 35 43 94
type_or_void         : 34
var_decl             : 15 55
variable             : 27 29 43
variables            : 22

Parsing method: LALR

state 0

    (0) S' -> . empty
    (1) empty -> .

    $end            reduce using rule 1 (empty -> .)

    empty                          shift and go to state 1

state 1

    (0) S' -> empty .


