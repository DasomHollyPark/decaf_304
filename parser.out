Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> class_decl_star
Rule 2     empty -> <empty>
Rule 3     class_decl_star -> empty
Rule 4     class_decl_star -> class_decl class_decl_star
Rule 5     class_decl -> CLASS ID LEFT_BRACE class_body_decl_plus RIGHT_BRACE
Rule 6     class_decl -> CLASS ID extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE
Rule 7     extends -> EXTENDS ID
Rule 8     class_body_decl_plus -> class_body_decl
Rule 9     class_body_decl_plus -> class_body_decl class_body_decl_plus
Rule 10    class_body_decl -> field_decl
Rule 11    class_body_decl -> method_decl
Rule 12    class_body_decl -> constructor_decl
Rule 13    field_decl -> modifier var_decl
Rule 14    modifier -> empty
Rule 15    modifier -> PUBLIC
Rule 16    modifier -> PRIVATE
Rule 17    modifier -> PUBLIC STATIC
Rule 18    modifier -> PRIVATE STATIC
Rule 19    modifier -> STATIC
Rule 20    var_decl -> type variables SEMICOLON
Rule 21    type -> INT
Rule 22    type -> FLOAT
Rule 23    type -> BOOLEAN
Rule 24    type -> ID
Rule 25    variables -> variable more_variables
Rule 26    more_variables -> empty
Rule 27    more_variables -> COMMA variable more_variables
Rule 28    variable -> ID array_dim_star
Rule 29    array_dim_star -> empty
Rule 30    array_dim_star -> array_dim array_dim_star
Rule 31    array_dim -> LEFT_BRACKET RIGHT_BRACKET
Rule 32    method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block
Rule 33    method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block
Rule 34    method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block
Rule 35    method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block
Rule 36    constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block
Rule 37    constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block
Rule 38    formals -> formal_param more_formals
Rule 39    more_formals -> empty
Rule 40    more_formals -> COMMA formal_param more_formals
Rule 41    formal_param -> type variable
Rule 42    block -> LEFT_BRACE stmt_star RIGHT_BRACE
Rule 43    stmt_star -> empty
Rule 44    stmt_star -> stmt stmt_star
Rule 45    stmt -> IF LEFT_PAR expr RIGHT_PAR stmt
Rule 46    stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt
Rule 47    stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt
Rule 48    stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
Rule 49    stmt -> RETURN expr_opt SEMICOLON
Rule 50    stmt -> stmt_expr SEMICOLON
Rule 51    stmt -> BREAK SEMICOLON
Rule 52    stmt -> CONTINUE SEMICOLON
Rule 53    stmt -> block
Rule 54    stmt -> var_decl
Rule 55    stmt -> SEMICOLON
Rule 56    literal -> INT_CONST
Rule 57    literal -> FLOAT_CONST
Rule 58    literal -> STRING_CONST
Rule 59    literal -> NULL
Rule 60    literal -> TRUE
Rule 61    literal -> FALSE
Rule 62    primary -> literal
Rule 63    primary -> THIS
Rule 64    primary -> SUPER
Rule 65    primary -> LEFT_PAR expr RIGHT_PAR
Rule 66    primary -> NEW ID LEFT_PAR RIGHT_PAR
Rule 67    primary -> NEW ID LEFT_PAR arguments RIGHT_PAR
Rule 68    primary -> lhs
Rule 69    primary -> method_invocation
Rule 70    arguments -> expr more_expr
Rule 71    more_expr -> empty
Rule 72    more_expr -> COMMA expr more_expr
Rule 73    lhs -> field_access
Rule 74    lhs -> array_access
Rule 75    field_access -> primary DOT ID
Rule 76    field_access -> ID
Rule 77    array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET
Rule 78    method_invocation -> field_access LEFT_PAR RIGHT_PAR
Rule 79    method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR
Rule 80    expr -> primary
Rule 81    expr -> assign
Rule 82    expr -> new_array
Rule 83    expr -> expr ARITH_OP expr
Rule 84    expr -> expr BOOL_OP expr
Rule 85    expr -> UNARY_OP expr
Rule 86    assign -> lhs EQUALS expr
Rule 87    assign -> lhs PLUS_PLUS
Rule 88    assign -> PLUS_PLUS lhs
Rule 89    assign -> lhs MINUS_MINUS
Rule 90    assign -> MINUS_MINUS lhs
Rule 91    new_array -> NEW type array_expr_plus array_empty_star
Rule 92    array_expr_plus -> array_expr
Rule 93    array_expr_plus -> array_expr array_expr_plus
Rule 94    array_expr -> LEFT_BRACKET expr RIGHT_BRACKET
Rule 95    array_empty_star -> empty
Rule 96    array_empty_star -> array_empty array_empty_star
Rule 97    array_empty -> LEFT_BRACKET RIGHT_BRACKET
Rule 98    stmt_expr -> assign
Rule 99    stmt_expr -> method_invocation
Rule 100   stmt_expr_opt -> empty
Rule 101   stmt_expr_opt -> stmt_expr
Rule 102   expr_opt -> empty
Rule 103   expr_opt -> expr

Terminals, with rules where they appear

ARITH_OP             : 83
BOOLEAN              : 23
BOOL_OP              : 84
BREAK                : 51
CLASS                : 5 6
COMMA                : 27 40 72
COMMENT              : 
CONTINUE             : 52
DO                   : 
DOT                  : 75
ELSE                 : 46
EQUALS               : 86
EXTENDS              : 7
FALSE                : 61
FLOAT                : 22
FLOAT_CONST          : 57
FOR                  : 48
ID                   : 5 6 7 24 28 32 33 34 35 36 37 66 67 75 76
IF                   : 45 46
INT                  : 21
INT_CONST            : 56
LEFT_BRACE           : 5 6 42
LEFT_BRACKET         : 31 77 94 97
LEFT_PAR             : 32 33 34 35 36 37 45 46 47 48 65 66 67 78 79
MINUS_MINUS          : 89 90
NEW                  : 66 67 91
NULL                 : 59
PLUS_PLUS            : 87 88
PRIVATE              : 16 18
PUBLIC               : 15 17
RETURN               : 49
RIGHT_BRACE          : 5 6 42
RIGHT_BRACKET        : 31 77 94 97
RIGHT_PAR            : 32 33 34 35 36 37 45 46 47 48 65 66 67 78 79
SEMICOLON            : 20 48 48 49 50 51 52 55
STATIC               : 17 18 19
STRING_CONST         : 58
SUPER                : 64
THIS                 : 63
TRUE                 : 60
UNARY_OP             : 85
VOID                 : 34 35
WHILE                : 47
error                : 

Nonterminals, with rules where they appear

arguments            : 67 79
array_access         : 74
array_dim            : 30
array_dim_star       : 28 30
array_empty          : 96
array_empty_star     : 91 96
array_expr           : 92 93
array_expr_plus      : 91 93
assign               : 81 98
block                : 32 33 34 35 36 37 53
class_body_decl      : 8 9
class_body_decl_plus : 5 6 9
class_decl           : 4
class_decl_star      : 1 4
constructor_decl     : 12
empty                : 3 14 26 29 39 43 71 95 100 102
expr                 : 45 46 47 65 70 72 77 83 83 84 84 85 86 94 103
expr_opt             : 48 49
extends              : 6
field_access         : 73 78 79
field_decl           : 10
formal_param         : 38 40
formals              : 32 34 37
lhs                  : 68 86 87 88 89 90
literal              : 62
method_decl          : 11
method_invocation    : 69 99
modifier             : 13 32 33 34 35 36 37
more_expr            : 70 72
more_formals         : 38 40
more_variables       : 25 27
new_array            : 82
primary              : 75 77 80
program              : 0
stmt                 : 44 45 46 46 47 48
stmt_expr            : 50 101
stmt_expr_opt        : 48 48
stmt_star            : 42 44
type                 : 20 32 33 41 91
var_decl             : 13 54
variable             : 25 27 41
variables            : 20

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_decl_star
    (3) class_decl_star -> . empty
    (4) class_decl_star -> . class_decl class_decl_star
    (2) empty -> .
    (5) class_decl -> . CLASS ID LEFT_BRACE class_body_decl_plus RIGHT_BRACE
    (6) class_decl -> . CLASS ID extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE

    $end            reduce using rule 2 (empty -> .)
    CLASS           shift and go to state 3

    program                        shift and go to state 1
    class_decl                     shift and go to state 2
    class_decl_star                shift and go to state 5
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (4) class_decl_star -> class_decl . class_decl_star
    (3) class_decl_star -> . empty
    (4) class_decl_star -> . class_decl class_decl_star
    (2) empty -> .
    (5) class_decl -> . CLASS ID LEFT_BRACE class_body_decl_plus RIGHT_BRACE
    (6) class_decl -> . CLASS ID extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE

    $end            reduce using rule 2 (empty -> .)
    CLASS           shift and go to state 3

    class_decl                     shift and go to state 2
    empty                          shift and go to state 4
    class_decl_star                shift and go to state 6

state 3

    (5) class_decl -> CLASS . ID LEFT_BRACE class_body_decl_plus RIGHT_BRACE
    (6) class_decl -> CLASS . ID extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE

    ID              shift and go to state 7


state 4

    (3) class_decl_star -> empty .

    $end            reduce using rule 3 (class_decl_star -> empty .)


state 5

    (1) program -> class_decl_star .

    $end            reduce using rule 1 (program -> class_decl_star .)


state 6

    (4) class_decl_star -> class_decl class_decl_star .

    $end            reduce using rule 4 (class_decl_star -> class_decl class_decl_star .)


state 7

    (5) class_decl -> CLASS ID . LEFT_BRACE class_body_decl_plus RIGHT_BRACE
    (6) class_decl -> CLASS ID . extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE
    (7) extends -> . EXTENDS ID

    LEFT_BRACE      shift and go to state 10
    EXTENDS         shift and go to state 8

    extends                        shift and go to state 9

state 8

    (7) extends -> EXTENDS . ID

    ID              shift and go to state 11


state 9

    (6) class_decl -> CLASS ID extends . LEFT_BRACE class_body_decl_plus RIGHT_BRACE

    LEFT_BRACE      shift and go to state 12


state 10

    (5) class_decl -> CLASS ID LEFT_BRACE . class_body_decl_plus RIGHT_BRACE
    (8) class_body_decl_plus -> . class_body_decl
    (9) class_body_decl_plus -> . class_body_decl class_body_decl_plus
    (10) class_body_decl -> . field_decl
    (11) class_body_decl -> . method_decl
    (12) class_body_decl -> . constructor_decl
    (13) field_decl -> . modifier var_decl
    (32) method_decl -> . modifier type ID LEFT_PAR formals RIGHT_PAR block
    (33) method_decl -> . modifier type ID LEFT_PAR RIGHT_PAR block
    (34) method_decl -> . modifier VOID ID LEFT_PAR formals RIGHT_PAR block
    (35) method_decl -> . modifier VOID ID LEFT_PAR RIGHT_PAR block
    (36) constructor_decl -> . modifier ID LEFT_PAR RIGHT_PAR block
    (37) constructor_decl -> . modifier ID LEFT_PAR formals RIGHT_PAR block
    (14) modifier -> . empty
    (15) modifier -> . PUBLIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . PUBLIC STATIC
    (18) modifier -> . PRIVATE STATIC
    (19) modifier -> . STATIC
    (2) empty -> .

    PUBLIC          shift and go to state 20
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 18
    VOID            reduce using rule 2 (empty -> .)
    ID              reduce using rule 2 (empty -> .)
    INT             reduce using rule 2 (empty -> .)
    FLOAT           reduce using rule 2 (empty -> .)
    BOOLEAN         reduce using rule 2 (empty -> .)

    class_body_decl                shift and go to state 13
    field_decl                     shift and go to state 15
    constructor_decl               shift and go to state 16
    method_decl                    shift and go to state 19
    empty                          shift and go to state 17
    class_body_decl_plus           shift and go to state 21
    modifier                       shift and go to state 22

state 11

    (7) extends -> EXTENDS ID .

    LEFT_BRACE      reduce using rule 7 (extends -> EXTENDS ID .)


state 12

    (6) class_decl -> CLASS ID extends LEFT_BRACE . class_body_decl_plus RIGHT_BRACE
    (8) class_body_decl_plus -> . class_body_decl
    (9) class_body_decl_plus -> . class_body_decl class_body_decl_plus
    (10) class_body_decl -> . field_decl
    (11) class_body_decl -> . method_decl
    (12) class_body_decl -> . constructor_decl
    (13) field_decl -> . modifier var_decl
    (32) method_decl -> . modifier type ID LEFT_PAR formals RIGHT_PAR block
    (33) method_decl -> . modifier type ID LEFT_PAR RIGHT_PAR block
    (34) method_decl -> . modifier VOID ID LEFT_PAR formals RIGHT_PAR block
    (35) method_decl -> . modifier VOID ID LEFT_PAR RIGHT_PAR block
    (36) constructor_decl -> . modifier ID LEFT_PAR RIGHT_PAR block
    (37) constructor_decl -> . modifier ID LEFT_PAR formals RIGHT_PAR block
    (14) modifier -> . empty
    (15) modifier -> . PUBLIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . PUBLIC STATIC
    (18) modifier -> . PRIVATE STATIC
    (19) modifier -> . STATIC
    (2) empty -> .

    PUBLIC          shift and go to state 20
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 18
    VOID            reduce using rule 2 (empty -> .)
    ID              reduce using rule 2 (empty -> .)
    INT             reduce using rule 2 (empty -> .)
    FLOAT           reduce using rule 2 (empty -> .)
    BOOLEAN         reduce using rule 2 (empty -> .)

    class_body_decl                shift and go to state 13
    field_decl                     shift and go to state 15
    constructor_decl               shift and go to state 16
    method_decl                    shift and go to state 19
    empty                          shift and go to state 17
    class_body_decl_plus           shift and go to state 23
    modifier                       shift and go to state 22

state 13

    (8) class_body_decl_plus -> class_body_decl .
    (9) class_body_decl_plus -> class_body_decl . class_body_decl_plus
    (8) class_body_decl_plus -> . class_body_decl
    (9) class_body_decl_plus -> . class_body_decl class_body_decl_plus
    (10) class_body_decl -> . field_decl
    (11) class_body_decl -> . method_decl
    (12) class_body_decl -> . constructor_decl
    (13) field_decl -> . modifier var_decl
    (32) method_decl -> . modifier type ID LEFT_PAR formals RIGHT_PAR block
    (33) method_decl -> . modifier type ID LEFT_PAR RIGHT_PAR block
    (34) method_decl -> . modifier VOID ID LEFT_PAR formals RIGHT_PAR block
    (35) method_decl -> . modifier VOID ID LEFT_PAR RIGHT_PAR block
    (36) constructor_decl -> . modifier ID LEFT_PAR RIGHT_PAR block
    (37) constructor_decl -> . modifier ID LEFT_PAR formals RIGHT_PAR block
    (14) modifier -> . empty
    (15) modifier -> . PUBLIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . PUBLIC STATIC
    (18) modifier -> . PRIVATE STATIC
    (19) modifier -> . STATIC
    (2) empty -> .

    RIGHT_BRACE     reduce using rule 8 (class_body_decl_plus -> class_body_decl .)
    PUBLIC          shift and go to state 20
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 18
    VOID            reduce using rule 2 (empty -> .)
    ID              reduce using rule 2 (empty -> .)
    INT             reduce using rule 2 (empty -> .)
    FLOAT           reduce using rule 2 (empty -> .)
    BOOLEAN         reduce using rule 2 (empty -> .)

    class_body_decl                shift and go to state 13
    field_decl                     shift and go to state 15
    constructor_decl               shift and go to state 16
    method_decl                    shift and go to state 19
    empty                          shift and go to state 17
    class_body_decl_plus           shift and go to state 24
    modifier                       shift and go to state 22

state 14

    (16) modifier -> PRIVATE .
    (18) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 16 (modifier -> PRIVATE .)
    ID              reduce using rule 16 (modifier -> PRIVATE .)
    INT             reduce using rule 16 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 16 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 16 (modifier -> PRIVATE .)
    STATIC          shift and go to state 25


state 15

    (10) class_body_decl -> field_decl .

    PUBLIC          reduce using rule 10 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 10 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 10 (class_body_decl -> field_decl .)
    VOID            reduce using rule 10 (class_body_decl -> field_decl .)
    ID              reduce using rule 10 (class_body_decl -> field_decl .)
    INT             reduce using rule 10 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 10 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 10 (class_body_decl -> field_decl .)
    RIGHT_BRACE     reduce using rule 10 (class_body_decl -> field_decl .)


state 16

    (12) class_body_decl -> constructor_decl .

    PUBLIC          reduce using rule 12 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 12 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 12 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 12 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 12 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 12 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 12 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 12 (class_body_decl -> constructor_decl .)
    RIGHT_BRACE     reduce using rule 12 (class_body_decl -> constructor_decl .)


state 17

    (14) modifier -> empty .

    VOID            reduce using rule 14 (modifier -> empty .)
    ID              reduce using rule 14 (modifier -> empty .)
    INT             reduce using rule 14 (modifier -> empty .)
    FLOAT           reduce using rule 14 (modifier -> empty .)
    BOOLEAN         reduce using rule 14 (modifier -> empty .)


state 18

    (19) modifier -> STATIC .

    VOID            reduce using rule 19 (modifier -> STATIC .)
    ID              reduce using rule 19 (modifier -> STATIC .)
    INT             reduce using rule 19 (modifier -> STATIC .)
    FLOAT           reduce using rule 19 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 19 (modifier -> STATIC .)


state 19

    (11) class_body_decl -> method_decl .

    PUBLIC          reduce using rule 11 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 11 (class_body_decl -> method_decl .)
    VOID            reduce using rule 11 (class_body_decl -> method_decl .)
    ID              reduce using rule 11 (class_body_decl -> method_decl .)
    INT             reduce using rule 11 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 11 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl -> method_decl .)
    RIGHT_BRACE     reduce using rule 11 (class_body_decl -> method_decl .)


state 20

    (15) modifier -> PUBLIC .
    (17) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 15 (modifier -> PUBLIC .)
    ID              reduce using rule 15 (modifier -> PUBLIC .)
    INT             reduce using rule 15 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 15 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 15 (modifier -> PUBLIC .)
    STATIC          shift and go to state 26


state 21

    (5) class_decl -> CLASS ID LEFT_BRACE class_body_decl_plus . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 27


state 22

    (13) field_decl -> modifier . var_decl
    (32) method_decl -> modifier . type ID LEFT_PAR formals RIGHT_PAR block
    (33) method_decl -> modifier . type ID LEFT_PAR RIGHT_PAR block
    (34) method_decl -> modifier . VOID ID LEFT_PAR formals RIGHT_PAR block
    (35) method_decl -> modifier . VOID ID LEFT_PAR RIGHT_PAR block
    (36) constructor_decl -> modifier . ID LEFT_PAR RIGHT_PAR block
    (37) constructor_decl -> modifier . ID LEFT_PAR formals RIGHT_PAR block
    (20) var_decl -> . type variables SEMICOLON
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    VOID            shift and go to state 30
    ID              shift and go to state 34
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32

    var_decl                       shift and go to state 31
    type                           shift and go to state 33

state 23

    (6) class_decl -> CLASS ID extends LEFT_BRACE class_body_decl_plus . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 35


state 24

    (9) class_body_decl_plus -> class_body_decl class_body_decl_plus .

    RIGHT_BRACE     reduce using rule 9 (class_body_decl_plus -> class_body_decl class_body_decl_plus .)


state 25

    (18) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 18 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 18 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 18 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 18 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 18 (modifier -> PRIVATE STATIC .)


state 26

    (17) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 17 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 17 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 17 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 17 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 17 (modifier -> PUBLIC STATIC .)


state 27

    (5) class_decl -> CLASS ID LEFT_BRACE class_body_decl_plus RIGHT_BRACE .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID LEFT_BRACE class_body_decl_plus RIGHT_BRACE .)
    $end            reduce using rule 5 (class_decl -> CLASS ID LEFT_BRACE class_body_decl_plus RIGHT_BRACE .)


state 28

    (22) type -> FLOAT .

    ID              reduce using rule 22 (type -> FLOAT .)
    LEFT_BRACKET    reduce using rule 22 (type -> FLOAT .)


state 29

    (21) type -> INT .

    ID              reduce using rule 21 (type -> INT .)
    LEFT_BRACKET    reduce using rule 21 (type -> INT .)


state 30

    (34) method_decl -> modifier VOID . ID LEFT_PAR formals RIGHT_PAR block
    (35) method_decl -> modifier VOID . ID LEFT_PAR RIGHT_PAR block

    ID              shift and go to state 36


state 31

    (13) field_decl -> modifier var_decl .

    PUBLIC          reduce using rule 13 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 13 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 13 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 13 (field_decl -> modifier var_decl .)
    ID              reduce using rule 13 (field_decl -> modifier var_decl .)
    INT             reduce using rule 13 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 13 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 13 (field_decl -> modifier var_decl .)
    RIGHT_BRACE     reduce using rule 13 (field_decl -> modifier var_decl .)


state 32

    (23) type -> BOOLEAN .

    ID              reduce using rule 23 (type -> BOOLEAN .)
    LEFT_BRACKET    reduce using rule 23 (type -> BOOLEAN .)


state 33

    (32) method_decl -> modifier type . ID LEFT_PAR formals RIGHT_PAR block
    (33) method_decl -> modifier type . ID LEFT_PAR RIGHT_PAR block
    (20) var_decl -> type . variables SEMICOLON
    (25) variables -> . variable more_variables
    (28) variable -> . ID array_dim_star

    ID              shift and go to state 39

    variables                      shift and go to state 37
    variable                       shift and go to state 38

state 34

    (36) constructor_decl -> modifier ID . LEFT_PAR RIGHT_PAR block
    (37) constructor_decl -> modifier ID . LEFT_PAR formals RIGHT_PAR block
    (24) type -> ID .

    LEFT_PAR        shift and go to state 40
    ID              reduce using rule 24 (type -> ID .)


state 35

    (6) class_decl -> CLASS ID extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE .

    CLASS           reduce using rule 6 (class_decl -> CLASS ID extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE .)
    $end            reduce using rule 6 (class_decl -> CLASS ID extends LEFT_BRACE class_body_decl_plus RIGHT_BRACE .)


state 36

    (34) method_decl -> modifier VOID ID . LEFT_PAR formals RIGHT_PAR block
    (35) method_decl -> modifier VOID ID . LEFT_PAR RIGHT_PAR block

    LEFT_PAR        shift and go to state 41


state 37

    (20) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 42


state 38

    (25) variables -> variable . more_variables
    (26) more_variables -> . empty
    (27) more_variables -> . COMMA variable more_variables
    (2) empty -> .

    COMMA           shift and go to state 44
    SEMICOLON       reduce using rule 2 (empty -> .)

    more_variables                 shift and go to state 43
    empty                          shift and go to state 45

state 39

    (32) method_decl -> modifier type ID . LEFT_PAR formals RIGHT_PAR block
    (33) method_decl -> modifier type ID . LEFT_PAR RIGHT_PAR block
    (28) variable -> ID . array_dim_star
    (29) array_dim_star -> . empty
    (30) array_dim_star -> . array_dim array_dim_star
    (2) empty -> .
    (31) array_dim -> . LEFT_BRACKET RIGHT_BRACKET

    LEFT_PAR        shift and go to state 47
    COMMA           reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 50

    array_dim                      shift and go to state 46
    array_dim_star                 shift and go to state 48
    empty                          shift and go to state 49

state 40

    (36) constructor_decl -> modifier ID LEFT_PAR . RIGHT_PAR block
    (37) constructor_decl -> modifier ID LEFT_PAR . formals RIGHT_PAR block
    (38) formals -> . formal_param more_formals
    (41) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    RIGHT_PAR       shift and go to state 52
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 54

    formal_param                   shift and go to state 51
    type                           shift and go to state 53
    formals                        shift and go to state 55

state 41

    (34) method_decl -> modifier VOID ID LEFT_PAR . formals RIGHT_PAR block
    (35) method_decl -> modifier VOID ID LEFT_PAR . RIGHT_PAR block
    (38) formals -> . formal_param more_formals
    (41) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    RIGHT_PAR       shift and go to state 56
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 54

    formal_param                   shift and go to state 51
    type                           shift and go to state 53
    formals                        shift and go to state 57

state 42

    (20) var_decl -> type variables SEMICOLON .

    IF              reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    LEFT_BRACE      reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    PLUS_PLUS       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    MINUS_MINUS     reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    LEFT_PAR        reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    INT_CONST       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FLOAT_CONST     reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    STRING_CONST    reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    RIGHT_BRACE     reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 20 (var_decl -> type variables SEMICOLON .)


state 43

    (25) variables -> variable more_variables .

    SEMICOLON       reduce using rule 25 (variables -> variable more_variables .)


state 44

    (27) more_variables -> COMMA . variable more_variables
    (28) variable -> . ID array_dim_star

    ID              shift and go to state 59

    variable                       shift and go to state 58

state 45

    (26) more_variables -> empty .

    SEMICOLON       reduce using rule 26 (more_variables -> empty .)


state 46

    (30) array_dim_star -> array_dim . array_dim_star
    (29) array_dim_star -> . empty
    (30) array_dim_star -> . array_dim array_dim_star
    (2) empty -> .
    (31) array_dim -> . LEFT_BRACKET RIGHT_BRACKET

    COMMA           reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    RIGHT_PAR       reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 50

    array_dim                      shift and go to state 46
    array_dim_star                 shift and go to state 60
    empty                          shift and go to state 49

state 47

    (32) method_decl -> modifier type ID LEFT_PAR . formals RIGHT_PAR block
    (33) method_decl -> modifier type ID LEFT_PAR . RIGHT_PAR block
    (38) formals -> . formal_param more_formals
    (41) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    RIGHT_PAR       shift and go to state 61
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 54

    formal_param                   shift and go to state 51
    type                           shift and go to state 53
    formals                        shift and go to state 62

state 48

    (28) variable -> ID array_dim_star .

    COMMA           reduce using rule 28 (variable -> ID array_dim_star .)
    SEMICOLON       reduce using rule 28 (variable -> ID array_dim_star .)
    RIGHT_PAR       reduce using rule 28 (variable -> ID array_dim_star .)


state 49

    (29) array_dim_star -> empty .

    COMMA           reduce using rule 29 (array_dim_star -> empty .)
    SEMICOLON       reduce using rule 29 (array_dim_star -> empty .)
    RIGHT_PAR       reduce using rule 29 (array_dim_star -> empty .)


state 50

    (31) array_dim -> LEFT_BRACKET . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 63


state 51

    (38) formals -> formal_param . more_formals
    (39) more_formals -> . empty
    (40) more_formals -> . COMMA formal_param more_formals
    (2) empty -> .

    COMMA           shift and go to state 64
    RIGHT_PAR       reduce using rule 2 (empty -> .)

    empty                          shift and go to state 65
    more_formals                   shift and go to state 66

state 52

    (36) constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 67

    block                          shift and go to state 68

state 53

    (41) formal_param -> type . variable
    (28) variable -> . ID array_dim_star

    ID              shift and go to state 59

    variable                       shift and go to state 69

state 54

    (24) type -> ID .

    ID              reduce using rule 24 (type -> ID .)


state 55

    (37) constructor_decl -> modifier ID LEFT_PAR formals . RIGHT_PAR block

    RIGHT_PAR       shift and go to state 70


state 56

    (35) method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 67

    block                          shift and go to state 71

state 57

    (34) method_decl -> modifier VOID ID LEFT_PAR formals . RIGHT_PAR block

    RIGHT_PAR       shift and go to state 72


state 58

    (27) more_variables -> COMMA variable . more_variables
    (26) more_variables -> . empty
    (27) more_variables -> . COMMA variable more_variables
    (2) empty -> .

    COMMA           shift and go to state 44
    SEMICOLON       reduce using rule 2 (empty -> .)

    more_variables                 shift and go to state 73
    empty                          shift and go to state 45

state 59

    (28) variable -> ID . array_dim_star
    (29) array_dim_star -> . empty
    (30) array_dim_star -> . array_dim array_dim_star
    (2) empty -> .
    (31) array_dim -> . LEFT_BRACKET RIGHT_BRACKET

    COMMA           reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    RIGHT_PAR       reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 50

    array_dim                      shift and go to state 46
    array_dim_star                 shift and go to state 48
    empty                          shift and go to state 49

state 60

    (30) array_dim_star -> array_dim array_dim_star .

    COMMA           reduce using rule 30 (array_dim_star -> array_dim array_dim_star .)
    SEMICOLON       reduce using rule 30 (array_dim_star -> array_dim array_dim_star .)
    RIGHT_PAR       reduce using rule 30 (array_dim_star -> array_dim array_dim_star .)


state 61

    (33) method_decl -> modifier type ID LEFT_PAR RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 67

    block                          shift and go to state 74

state 62

    (32) method_decl -> modifier type ID LEFT_PAR formals . RIGHT_PAR block

    RIGHT_PAR       shift and go to state 75


state 63

    (31) array_dim -> LEFT_BRACKET RIGHT_BRACKET .

    LEFT_BRACKET    reduce using rule 31 (array_dim -> LEFT_BRACKET RIGHT_BRACKET .)
    COMMA           reduce using rule 31 (array_dim -> LEFT_BRACKET RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 31 (array_dim -> LEFT_BRACKET RIGHT_BRACKET .)
    RIGHT_PAR       reduce using rule 31 (array_dim -> LEFT_BRACKET RIGHT_BRACKET .)


state 64

    (40) more_formals -> COMMA . formal_param more_formals
    (41) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 54

    formal_param                   shift and go to state 76
    type                           shift and go to state 53

state 65

    (39) more_formals -> empty .

    RIGHT_PAR       reduce using rule 39 (more_formals -> empty .)


state 66

    (38) formals -> formal_param more_formals .

    RIGHT_PAR       reduce using rule 38 (formals -> formal_param more_formals .)


state 67

    (42) block -> LEFT_BRACE . stmt_star RIGHT_BRACE
    (43) stmt_star -> . empty
    (44) stmt_star -> . stmt stmt_star
    (2) empty -> .
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt
    (46) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt
    (47) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (48) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (49) stmt -> . RETURN expr_opt SEMICOLON
    (50) stmt -> . stmt_expr SEMICOLON
    (51) stmt -> . BREAK SEMICOLON
    (52) stmt -> . CONTINUE SEMICOLON
    (53) stmt -> . block
    (54) stmt -> . var_decl
    (55) stmt -> . SEMICOLON
    (98) stmt_expr -> . assign
    (99) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (20) var_decl -> . type variables SEMICOLON
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 2 (empty -> .)
    IF              shift and go to state 97
    WHILE           shift and go to state 78
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 100
    CONTINUE        shift and go to state 102
    SEMICOLON       shift and go to state 85
    LEFT_BRACE      shift and go to state 67
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 96
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 92
    array_access                   shift and go to state 81
    var_decl                       shift and go to state 99
    primary                        shift and go to state 84
    stmt                           shift and go to state 94
    stmt_expr                      shift and go to state 87
    literal                        shift and go to state 88
    lhs                            shift and go to state 103
    block                          shift and go to state 109
    type                           shift and go to state 90
    method_invocation              shift and go to state 89
    stmt_star                      shift and go to state 95
    assign                         shift and go to state 108
    empty                          shift and go to state 91

state 68

    (36) constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .

    PUBLIC          reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)
    PRIVATE         reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)
    STATIC          reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)
    VOID            reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)
    ID              reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)
    INT             reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)
    FLOAT           reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)
    BOOLEAN         reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 36 (constructor_decl -> modifier ID LEFT_PAR RIGHT_PAR block .)


state 69

    (41) formal_param -> type variable .

    COMMA           reduce using rule 41 (formal_param -> type variable .)
    RIGHT_PAR       reduce using rule 41 (formal_param -> type variable .)


state 70

    (37) constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 67

    block                          shift and go to state 111

state 71

    (35) method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .

    PUBLIC          reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)
    PRIVATE         reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)
    STATIC          reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)
    VOID            reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)
    ID              reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)
    INT             reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)
    FLOAT           reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)
    BOOLEAN         reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 35 (method_decl -> modifier VOID ID LEFT_PAR RIGHT_PAR block .)


state 72

    (34) method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 67

    block                          shift and go to state 112

state 73

    (27) more_variables -> COMMA variable more_variables .

    SEMICOLON       reduce using rule 27 (more_variables -> COMMA variable more_variables .)


state 74

    (33) method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .

    PUBLIC          reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)
    PRIVATE         reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)
    STATIC          reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)
    VOID            reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)
    ID              reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)
    INT             reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)
    FLOAT           reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)
    BOOLEAN         reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR RIGHT_PAR block .)


state 75

    (32) method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 67

    block                          shift and go to state 113

state 76

    (40) more_formals -> COMMA formal_param . more_formals
    (39) more_formals -> . empty
    (40) more_formals -> . COMMA formal_param more_formals
    (2) empty -> .

    COMMA           shift and go to state 64
    RIGHT_PAR       reduce using rule 2 (empty -> .)

    empty                          shift and go to state 65
    more_formals                   shift and go to state 114

state 77

    (49) stmt -> RETURN . expr_opt SEMICOLON
    (102) expr_opt -> . empty
    (103) expr_opt -> . expr
    (2) empty -> .
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    SEMICOLON       reduce using rule 2 (empty -> .)
    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 123
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    expr_opt                       shift and go to state 118
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126
    empty                          shift and go to state 120

state 78

    (47) stmt -> WHILE . LEFT_PAR expr RIGHT_PAR stmt

    LEFT_PAR        shift and go to state 127


state 79

    (66) primary -> NEW . ID LEFT_PAR RIGHT_PAR
    (67) primary -> NEW . ID LEFT_PAR arguments RIGHT_PAR

    ID              shift and go to state 128


state 80

    (59) literal -> NULL .

    DOT             reduce using rule 59 (literal -> NULL .)
    LEFT_BRACKET    reduce using rule 59 (literal -> NULL .)
    RIGHT_BRACKET   reduce using rule 59 (literal -> NULL .)
    ARITH_OP        reduce using rule 59 (literal -> NULL .)
    BOOL_OP         reduce using rule 59 (literal -> NULL .)
    SEMICOLON       reduce using rule 59 (literal -> NULL .)
    COMMA           reduce using rule 59 (literal -> NULL .)
    RIGHT_PAR       reduce using rule 59 (literal -> NULL .)


state 81

    (74) lhs -> array_access .

    EQUALS          reduce using rule 74 (lhs -> array_access .)
    PLUS_PLUS       reduce using rule 74 (lhs -> array_access .)
    MINUS_MINUS     reduce using rule 74 (lhs -> array_access .)
    DOT             reduce using rule 74 (lhs -> array_access .)
    LEFT_BRACKET    reduce using rule 74 (lhs -> array_access .)
    ARITH_OP        reduce using rule 74 (lhs -> array_access .)
    BOOL_OP         reduce using rule 74 (lhs -> array_access .)
    SEMICOLON       reduce using rule 74 (lhs -> array_access .)
    RIGHT_PAR       reduce using rule 74 (lhs -> array_access .)
    RIGHT_BRACKET   reduce using rule 74 (lhs -> array_access .)
    COMMA           reduce using rule 74 (lhs -> array_access .)


state 82

    (58) literal -> STRING_CONST .

    DOT             reduce using rule 58 (literal -> STRING_CONST .)
    LEFT_BRACKET    reduce using rule 58 (literal -> STRING_CONST .)
    RIGHT_BRACKET   reduce using rule 58 (literal -> STRING_CONST .)
    ARITH_OP        reduce using rule 58 (literal -> STRING_CONST .)
    BOOL_OP         reduce using rule 58 (literal -> STRING_CONST .)
    SEMICOLON       reduce using rule 58 (literal -> STRING_CONST .)
    COMMA           reduce using rule 58 (literal -> STRING_CONST .)
    RIGHT_PAR       reduce using rule 58 (literal -> STRING_CONST .)


state 83

    (56) literal -> INT_CONST .

    DOT             reduce using rule 56 (literal -> INT_CONST .)
    LEFT_BRACKET    reduce using rule 56 (literal -> INT_CONST .)
    RIGHT_BRACKET   reduce using rule 56 (literal -> INT_CONST .)
    ARITH_OP        reduce using rule 56 (literal -> INT_CONST .)
    BOOL_OP         reduce using rule 56 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 56 (literal -> INT_CONST .)
    COMMA           reduce using rule 56 (literal -> INT_CONST .)
    RIGHT_PAR       reduce using rule 56 (literal -> INT_CONST .)


state 84

    (75) field_access -> primary . DOT ID
    (77) array_access -> primary . LEFT_BRACKET expr RIGHT_BRACKET

    DOT             shift and go to state 130
    LEFT_BRACKET    shift and go to state 129


state 85

    (55) stmt -> SEMICOLON .

    IF              reduce using rule 55 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 55 (stmt -> SEMICOLON .)
    FOR             reduce using rule 55 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 55 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 55 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 55 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 55 (stmt -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 55 (stmt -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 55 (stmt -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 55 (stmt -> SEMICOLON .)
    INT             reduce using rule 55 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 55 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 55 (stmt -> SEMICOLON .)
    ID              reduce using rule 55 (stmt -> SEMICOLON .)
    THIS            reduce using rule 55 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 55 (stmt -> SEMICOLON .)
    LEFT_PAR        reduce using rule 55 (stmt -> SEMICOLON .)
    NEW             reduce using rule 55 (stmt -> SEMICOLON .)
    INT_CONST       reduce using rule 55 (stmt -> SEMICOLON .)
    FLOAT_CONST     reduce using rule 55 (stmt -> SEMICOLON .)
    STRING_CONST    reduce using rule 55 (stmt -> SEMICOLON .)
    NULL            reduce using rule 55 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 55 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 55 (stmt -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 55 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 55 (stmt -> SEMICOLON .)


state 86

    (60) literal -> TRUE .

    DOT             reduce using rule 60 (literal -> TRUE .)
    LEFT_BRACKET    reduce using rule 60 (literal -> TRUE .)
    RIGHT_BRACKET   reduce using rule 60 (literal -> TRUE .)
    ARITH_OP        reduce using rule 60 (literal -> TRUE .)
    BOOL_OP         reduce using rule 60 (literal -> TRUE .)
    SEMICOLON       reduce using rule 60 (literal -> TRUE .)
    COMMA           reduce using rule 60 (literal -> TRUE .)
    RIGHT_PAR       reduce using rule 60 (literal -> TRUE .)


state 87

    (50) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 131


state 88

    (62) primary -> literal .

    DOT             reduce using rule 62 (primary -> literal .)
    LEFT_BRACKET    reduce using rule 62 (primary -> literal .)
    ARITH_OP        reduce using rule 62 (primary -> literal .)
    BOOL_OP         reduce using rule 62 (primary -> literal .)
    COMMA           reduce using rule 62 (primary -> literal .)
    RIGHT_PAR       reduce using rule 62 (primary -> literal .)
    RIGHT_BRACKET   reduce using rule 62 (primary -> literal .)
    SEMICOLON       reduce using rule 62 (primary -> literal .)


state 89

    (99) stmt_expr -> method_invocation .
    (69) primary -> method_invocation .

    SEMICOLON       reduce using rule 99 (stmt_expr -> method_invocation .)
    RIGHT_PAR       reduce using rule 99 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 69 (primary -> method_invocation .)
    LEFT_BRACKET    reduce using rule 69 (primary -> method_invocation .)


state 90

    (20) var_decl -> type . variables SEMICOLON
    (25) variables -> . variable more_variables
    (28) variable -> . ID array_dim_star

    ID              shift and go to state 59

    variable                       shift and go to state 38
    variables                      shift and go to state 37

state 91

    (43) stmt_star -> empty .

    RIGHT_BRACE     reduce using rule 43 (stmt_star -> empty .)


state 92

    (78) method_invocation -> field_access . LEFT_PAR RIGHT_PAR
    (79) method_invocation -> field_access . LEFT_PAR arguments RIGHT_PAR
    (73) lhs -> field_access .

    LEFT_PAR        shift and go to state 132
    EQUALS          reduce using rule 73 (lhs -> field_access .)
    PLUS_PLUS       reduce using rule 73 (lhs -> field_access .)
    MINUS_MINUS     reduce using rule 73 (lhs -> field_access .)
    DOT             reduce using rule 73 (lhs -> field_access .)
    LEFT_BRACKET    reduce using rule 73 (lhs -> field_access .)


state 93

    (48) stmt -> FOR . LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt

    LEFT_PAR        shift and go to state 133


state 94

    (44) stmt_star -> stmt . stmt_star
    (43) stmt_star -> . empty
    (44) stmt_star -> . stmt stmt_star
    (2) empty -> .
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt
    (46) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt
    (47) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (48) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (49) stmt -> . RETURN expr_opt SEMICOLON
    (50) stmt -> . stmt_expr SEMICOLON
    (51) stmt -> . BREAK SEMICOLON
    (52) stmt -> . CONTINUE SEMICOLON
    (53) stmt -> . block
    (54) stmt -> . var_decl
    (55) stmt -> . SEMICOLON
    (98) stmt_expr -> . assign
    (99) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (20) var_decl -> . type variables SEMICOLON
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 2 (empty -> .)
    IF              shift and go to state 97
    WHILE           shift and go to state 78
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 100
    CONTINUE        shift and go to state 102
    SEMICOLON       shift and go to state 85
    LEFT_BRACE      shift and go to state 67
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 96
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 92
    array_access                   shift and go to state 81
    var_decl                       shift and go to state 99
    primary                        shift and go to state 84
    stmt                           shift and go to state 94
    stmt_expr                      shift and go to state 87
    literal                        shift and go to state 88
    lhs                            shift and go to state 103
    block                          shift and go to state 109
    type                           shift and go to state 90
    method_invocation              shift and go to state 89
    stmt_star                      shift and go to state 134
    assign                         shift and go to state 108
    empty                          shift and go to state 91

state 95

    (42) block -> LEFT_BRACE stmt_star . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 135


state 96

    (24) type -> ID .
    (76) field_access -> ID .

    ID              reduce using rule 24 (type -> ID .)
    LEFT_PAR        reduce using rule 76 (field_access -> ID .)
    EQUALS          reduce using rule 76 (field_access -> ID .)
    PLUS_PLUS       reduce using rule 76 (field_access -> ID .)
    MINUS_MINUS     reduce using rule 76 (field_access -> ID .)
    DOT             reduce using rule 76 (field_access -> ID .)
    LEFT_BRACKET    reduce using rule 76 (field_access -> ID .)


state 97

    (45) stmt -> IF . LEFT_PAR expr RIGHT_PAR stmt
    (46) stmt -> IF . LEFT_PAR expr RIGHT_PAR stmt ELSE stmt

    LEFT_PAR        shift and go to state 136


state 98

    (61) literal -> FALSE .

    DOT             reduce using rule 61 (literal -> FALSE .)
    LEFT_BRACKET    reduce using rule 61 (literal -> FALSE .)
    RIGHT_BRACKET   reduce using rule 61 (literal -> FALSE .)
    ARITH_OP        reduce using rule 61 (literal -> FALSE .)
    BOOL_OP         reduce using rule 61 (literal -> FALSE .)
    SEMICOLON       reduce using rule 61 (literal -> FALSE .)
    COMMA           reduce using rule 61 (literal -> FALSE .)
    RIGHT_PAR       reduce using rule 61 (literal -> FALSE .)


state 99

    (54) stmt -> var_decl .

    IF              reduce using rule 54 (stmt -> var_decl .)
    WHILE           reduce using rule 54 (stmt -> var_decl .)
    FOR             reduce using rule 54 (stmt -> var_decl .)
    RETURN          reduce using rule 54 (stmt -> var_decl .)
    BREAK           reduce using rule 54 (stmt -> var_decl .)
    CONTINUE        reduce using rule 54 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 54 (stmt -> var_decl .)
    LEFT_BRACE      reduce using rule 54 (stmt -> var_decl .)
    PLUS_PLUS       reduce using rule 54 (stmt -> var_decl .)
    MINUS_MINUS     reduce using rule 54 (stmt -> var_decl .)
    INT             reduce using rule 54 (stmt -> var_decl .)
    FLOAT           reduce using rule 54 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 54 (stmt -> var_decl .)
    ID              reduce using rule 54 (stmt -> var_decl .)
    THIS            reduce using rule 54 (stmt -> var_decl .)
    SUPER           reduce using rule 54 (stmt -> var_decl .)
    LEFT_PAR        reduce using rule 54 (stmt -> var_decl .)
    NEW             reduce using rule 54 (stmt -> var_decl .)
    INT_CONST       reduce using rule 54 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 54 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 54 (stmt -> var_decl .)
    NULL            reduce using rule 54 (stmt -> var_decl .)
    TRUE            reduce using rule 54 (stmt -> var_decl .)
    FALSE           reduce using rule 54 (stmt -> var_decl .)
    RIGHT_BRACE     reduce using rule 54 (stmt -> var_decl .)
    ELSE            reduce using rule 54 (stmt -> var_decl .)


state 100

    (51) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 137


state 101

    (63) primary -> THIS .

    DOT             reduce using rule 63 (primary -> THIS .)
    LEFT_BRACKET    reduce using rule 63 (primary -> THIS .)
    ARITH_OP        reduce using rule 63 (primary -> THIS .)
    BOOL_OP         reduce using rule 63 (primary -> THIS .)
    COMMA           reduce using rule 63 (primary -> THIS .)
    RIGHT_PAR       reduce using rule 63 (primary -> THIS .)
    RIGHT_BRACKET   reduce using rule 63 (primary -> THIS .)
    SEMICOLON       reduce using rule 63 (primary -> THIS .)


state 102

    (52) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 138


state 103

    (86) assign -> lhs . EQUALS expr
    (87) assign -> lhs . PLUS_PLUS
    (89) assign -> lhs . MINUS_MINUS
    (68) primary -> lhs .

    EQUALS          shift and go to state 139
    PLUS_PLUS       shift and go to state 140
    MINUS_MINUS     shift and go to state 141
    DOT             reduce using rule 68 (primary -> lhs .)
    LEFT_BRACKET    reduce using rule 68 (primary -> lhs .)


state 104

    (90) assign -> MINUS_MINUS . lhs
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR

    ID              shift and go to state 122
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 121
    primary                        shift and go to state 84
    literal                        shift and go to state 88
    lhs                            shift and go to state 142
    method_invocation              shift and go to state 119
    array_access                   shift and go to state 81

state 105

    (88) assign -> PLUS_PLUS . lhs
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR

    ID              shift and go to state 122
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 121
    primary                        shift and go to state 84
    literal                        shift and go to state 88
    lhs                            shift and go to state 143
    method_invocation              shift and go to state 119
    array_access                   shift and go to state 81

state 106

    (65) primary -> LEFT_PAR . expr RIGHT_PAR
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 144
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 107

    (64) primary -> SUPER .

    DOT             reduce using rule 64 (primary -> SUPER .)
    LEFT_BRACKET    reduce using rule 64 (primary -> SUPER .)
    ARITH_OP        reduce using rule 64 (primary -> SUPER .)
    BOOL_OP         reduce using rule 64 (primary -> SUPER .)
    COMMA           reduce using rule 64 (primary -> SUPER .)
    RIGHT_PAR       reduce using rule 64 (primary -> SUPER .)
    RIGHT_BRACKET   reduce using rule 64 (primary -> SUPER .)
    SEMICOLON       reduce using rule 64 (primary -> SUPER .)


state 108

    (98) stmt_expr -> assign .

    SEMICOLON       reduce using rule 98 (stmt_expr -> assign .)
    RIGHT_PAR       reduce using rule 98 (stmt_expr -> assign .)


state 109

    (53) stmt -> block .

    IF              reduce using rule 53 (stmt -> block .)
    WHILE           reduce using rule 53 (stmt -> block .)
    FOR             reduce using rule 53 (stmt -> block .)
    RETURN          reduce using rule 53 (stmt -> block .)
    BREAK           reduce using rule 53 (stmt -> block .)
    CONTINUE        reduce using rule 53 (stmt -> block .)
    SEMICOLON       reduce using rule 53 (stmt -> block .)
    LEFT_BRACE      reduce using rule 53 (stmt -> block .)
    PLUS_PLUS       reduce using rule 53 (stmt -> block .)
    MINUS_MINUS     reduce using rule 53 (stmt -> block .)
    INT             reduce using rule 53 (stmt -> block .)
    FLOAT           reduce using rule 53 (stmt -> block .)
    BOOLEAN         reduce using rule 53 (stmt -> block .)
    ID              reduce using rule 53 (stmt -> block .)
    THIS            reduce using rule 53 (stmt -> block .)
    SUPER           reduce using rule 53 (stmt -> block .)
    LEFT_PAR        reduce using rule 53 (stmt -> block .)
    NEW             reduce using rule 53 (stmt -> block .)
    INT_CONST       reduce using rule 53 (stmt -> block .)
    FLOAT_CONST     reduce using rule 53 (stmt -> block .)
    STRING_CONST    reduce using rule 53 (stmt -> block .)
    NULL            reduce using rule 53 (stmt -> block .)
    TRUE            reduce using rule 53 (stmt -> block .)
    FALSE           reduce using rule 53 (stmt -> block .)
    RIGHT_BRACE     reduce using rule 53 (stmt -> block .)
    ELSE            reduce using rule 53 (stmt -> block .)


state 110

    (57) literal -> FLOAT_CONST .

    DOT             reduce using rule 57 (literal -> FLOAT_CONST .)
    LEFT_BRACKET    reduce using rule 57 (literal -> FLOAT_CONST .)
    RIGHT_BRACKET   reduce using rule 57 (literal -> FLOAT_CONST .)
    ARITH_OP        reduce using rule 57 (literal -> FLOAT_CONST .)
    BOOL_OP         reduce using rule 57 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 57 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 57 (literal -> FLOAT_CONST .)
    RIGHT_PAR       reduce using rule 57 (literal -> FLOAT_CONST .)


state 111

    (37) constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .

    PUBLIC          reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)
    PRIVATE         reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)
    STATIC          reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)
    VOID            reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)
    ID              reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)
    INT             reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)
    FLOAT           reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)
    BOOLEAN         reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 37 (constructor_decl -> modifier ID LEFT_PAR formals RIGHT_PAR block .)


state 112

    (34) method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .

    PUBLIC          reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)
    PRIVATE         reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)
    STATIC          reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)
    VOID            reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)
    ID              reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)
    INT             reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)
    FLOAT           reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)
    BOOLEAN         reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals RIGHT_PAR block .)


state 113

    (32) method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .

    PUBLIC          reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)
    PRIVATE         reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)
    STATIC          reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)
    VOID            reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)
    ID              reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)
    INT             reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)
    FLOAT           reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)
    BOOLEAN         reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 32 (method_decl -> modifier type ID LEFT_PAR formals RIGHT_PAR block .)


state 114

    (40) more_formals -> COMMA formal_param more_formals .

    RIGHT_PAR       reduce using rule 40 (more_formals -> COMMA formal_param more_formals .)


state 115

    (82) expr -> new_array .

    ARITH_OP        reduce using rule 82 (expr -> new_array .)
    BOOL_OP         reduce using rule 82 (expr -> new_array .)
    SEMICOLON       reduce using rule 82 (expr -> new_array .)
    RIGHT_PAR       reduce using rule 82 (expr -> new_array .)
    RIGHT_BRACKET   reduce using rule 82 (expr -> new_array .)
    COMMA           reduce using rule 82 (expr -> new_array .)


state 116

    (80) expr -> primary .
    (75) field_access -> primary . DOT ID
    (77) array_access -> primary . LEFT_BRACKET expr RIGHT_BRACKET

    ARITH_OP        reduce using rule 80 (expr -> primary .)
    BOOL_OP         reduce using rule 80 (expr -> primary .)
    SEMICOLON       reduce using rule 80 (expr -> primary .)
    RIGHT_PAR       reduce using rule 80 (expr -> primary .)
    RIGHT_BRACKET   reduce using rule 80 (expr -> primary .)
    COMMA           reduce using rule 80 (expr -> primary .)
    DOT             shift and go to state 130
    LEFT_BRACKET    shift and go to state 129


state 117

    (66) primary -> NEW . ID LEFT_PAR RIGHT_PAR
    (67) primary -> NEW . ID LEFT_PAR arguments RIGHT_PAR
    (91) new_array -> NEW . type array_expr_plus array_empty_star
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    ID              shift and go to state 146
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32

    type                           shift and go to state 145

state 118

    (49) stmt -> RETURN expr_opt . SEMICOLON

    SEMICOLON       shift and go to state 147


state 119

    (69) primary -> method_invocation .

    DOT             reduce using rule 69 (primary -> method_invocation .)
    LEFT_BRACKET    reduce using rule 69 (primary -> method_invocation .)
    ARITH_OP        reduce using rule 69 (primary -> method_invocation .)
    BOOL_OP         reduce using rule 69 (primary -> method_invocation .)
    COMMA           reduce using rule 69 (primary -> method_invocation .)
    RIGHT_PAR       reduce using rule 69 (primary -> method_invocation .)
    RIGHT_BRACKET   reduce using rule 69 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 69 (primary -> method_invocation .)


state 120

    (102) expr_opt -> empty .

    SEMICOLON       reduce using rule 102 (expr_opt -> empty .)


state 121

    (73) lhs -> field_access .
    (78) method_invocation -> field_access . LEFT_PAR RIGHT_PAR
    (79) method_invocation -> field_access . LEFT_PAR arguments RIGHT_PAR

    EQUALS          reduce using rule 73 (lhs -> field_access .)
    PLUS_PLUS       reduce using rule 73 (lhs -> field_access .)
    MINUS_MINUS     reduce using rule 73 (lhs -> field_access .)
    DOT             reduce using rule 73 (lhs -> field_access .)
    LEFT_BRACKET    reduce using rule 73 (lhs -> field_access .)
    ARITH_OP        reduce using rule 73 (lhs -> field_access .)
    BOOL_OP         reduce using rule 73 (lhs -> field_access .)
    SEMICOLON       reduce using rule 73 (lhs -> field_access .)
    RIGHT_PAR       reduce using rule 73 (lhs -> field_access .)
    RIGHT_BRACKET   reduce using rule 73 (lhs -> field_access .)
    COMMA           reduce using rule 73 (lhs -> field_access .)
    LEFT_PAR        shift and go to state 132


state 122

    (76) field_access -> ID .

    LEFT_PAR        reduce using rule 76 (field_access -> ID .)
    SEMICOLON       reduce using rule 76 (field_access -> ID .)
    ARITH_OP        reduce using rule 76 (field_access -> ID .)
    BOOL_OP         reduce using rule 76 (field_access -> ID .)
    DOT             reduce using rule 76 (field_access -> ID .)
    LEFT_BRACKET    reduce using rule 76 (field_access -> ID .)
    RIGHT_PAR       reduce using rule 76 (field_access -> ID .)
    RIGHT_BRACKET   reduce using rule 76 (field_access -> ID .)
    COMMA           reduce using rule 76 (field_access -> ID .)
    EQUALS          reduce using rule 76 (field_access -> ID .)
    PLUS_PLUS       reduce using rule 76 (field_access -> ID .)
    MINUS_MINUS     reduce using rule 76 (field_access -> ID .)


state 123

    (103) expr_opt -> expr .
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

    SEMICOLON       reduce using rule 103 (expr_opt -> expr .)
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149


state 124

    (68) primary -> lhs .
    (86) assign -> lhs . EQUALS expr
    (87) assign -> lhs . PLUS_PLUS
    (89) assign -> lhs . MINUS_MINUS

    DOT             reduce using rule 68 (primary -> lhs .)
    LEFT_BRACKET    reduce using rule 68 (primary -> lhs .)
    ARITH_OP        reduce using rule 68 (primary -> lhs .)
    BOOL_OP         reduce using rule 68 (primary -> lhs .)
    COMMA           reduce using rule 68 (primary -> lhs .)
    RIGHT_PAR       reduce using rule 68 (primary -> lhs .)
    RIGHT_BRACKET   reduce using rule 68 (primary -> lhs .)
    SEMICOLON       reduce using rule 68 (primary -> lhs .)
    EQUALS          shift and go to state 139
    PLUS_PLUS       shift and go to state 140
    MINUS_MINUS     shift and go to state 141


state 125

    (85) expr -> UNARY_OP . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 150
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 126

    (81) expr -> assign .

    ARITH_OP        reduce using rule 81 (expr -> assign .)
    BOOL_OP         reduce using rule 81 (expr -> assign .)
    SEMICOLON       reduce using rule 81 (expr -> assign .)
    RIGHT_PAR       reduce using rule 81 (expr -> assign .)
    RIGHT_BRACKET   reduce using rule 81 (expr -> assign .)
    COMMA           reduce using rule 81 (expr -> assign .)


state 127

    (47) stmt -> WHILE LEFT_PAR . expr RIGHT_PAR stmt
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 151
    primary                        shift and go to state 116
    literal                        shift and go to state 88
    array_access                   shift and go to state 81
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 128

    (66) primary -> NEW ID . LEFT_PAR RIGHT_PAR
    (67) primary -> NEW ID . LEFT_PAR arguments RIGHT_PAR

    LEFT_PAR        shift and go to state 152


state 129

    (77) array_access -> primary LEFT_BRACKET . expr RIGHT_BRACKET
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 153
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 130

    (75) field_access -> primary DOT . ID

    ID              shift and go to state 154


state 131

    (50) stmt -> stmt_expr SEMICOLON .

    IF              reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    LEFT_BRACE      reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    LEFT_PAR        reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    RIGHT_BRACE     reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 50 (stmt -> stmt_expr SEMICOLON .)


state 132

    (78) method_invocation -> field_access LEFT_PAR . RIGHT_PAR
    (79) method_invocation -> field_access LEFT_PAR . arguments RIGHT_PAR
    (70) arguments -> . expr more_expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    RIGHT_PAR       shift and go to state 156
    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    field_access                   shift and go to state 121
    new_array                      shift and go to state 115
    expr                           shift and go to state 157
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    arguments                      shift and go to state 155
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 133

    (48) stmt -> FOR LEFT_PAR . stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (100) stmt_expr_opt -> . empty
    (101) stmt_expr_opt -> . stmt_expr
    (2) empty -> .
    (98) stmt_expr -> . assign
    (99) stmt_expr -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    SEMICOLON       reduce using rule 2 (empty -> .)
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    ID              shift and go to state 122
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 92
    primary                        shift and go to state 84
    stmt_expr_opt                  shift and go to state 159
    stmt_expr                      shift and go to state 158
    literal                        shift and go to state 88
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 89
    array_access                   shift and go to state 81
    assign                         shift and go to state 108
    empty                          shift and go to state 160

state 134

    (44) stmt_star -> stmt stmt_star .

    RIGHT_BRACE     reduce using rule 44 (stmt_star -> stmt stmt_star .)


state 135

    (42) block -> LEFT_BRACE stmt_star RIGHT_BRACE .

    PUBLIC          reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    PRIVATE         reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    STATIC          reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    VOID            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    ID              reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    INT             reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    FLOAT           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    BOOLEAN         reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    IF              reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    WHILE           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    FOR             reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    RETURN          reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    BREAK           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    CONTINUE        reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    SEMICOLON       reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    PLUS_PLUS       reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    MINUS_MINUS     reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    THIS            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    SUPER           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    LEFT_PAR        reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    NEW             reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    INT_CONST       reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    FLOAT_CONST     reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    STRING_CONST    reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    NULL            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    TRUE            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    FALSE           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    ELSE            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)


state 136

    (45) stmt -> IF LEFT_PAR . expr RIGHT_PAR stmt
    (46) stmt -> IF LEFT_PAR . expr RIGHT_PAR stmt ELSE stmt
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 161
    primary                        shift and go to state 116
    literal                        shift and go to state 88
    array_access                   shift and go to state 81
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 137

    (51) stmt -> BREAK SEMICOLON .

    IF              reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    LEFT_BRACE      reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    PLUS_PLUS       reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    MINUS_MINUS     reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    LEFT_PAR        reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    STRING_CONST    reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    RIGHT_BRACE     reduce using rule 51 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 51 (stmt -> BREAK SEMICOLON .)


state 138

    (52) stmt -> CONTINUE SEMICOLON .

    IF              reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    LEFT_BRACE      reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    PLUS_PLUS       reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    MINUS_MINUS     reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    LEFT_PAR        reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    STRING_CONST    reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    RIGHT_BRACE     reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 52 (stmt -> CONTINUE SEMICOLON .)


state 139

    (86) assign -> lhs EQUALS . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 162
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 140

    (87) assign -> lhs PLUS_PLUS .

    ARITH_OP        reduce using rule 87 (assign -> lhs PLUS_PLUS .)
    BOOL_OP         reduce using rule 87 (assign -> lhs PLUS_PLUS .)
    COMMA           reduce using rule 87 (assign -> lhs PLUS_PLUS .)
    RIGHT_PAR       reduce using rule 87 (assign -> lhs PLUS_PLUS .)
    SEMICOLON       reduce using rule 87 (assign -> lhs PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 87 (assign -> lhs PLUS_PLUS .)


state 141

    (89) assign -> lhs MINUS_MINUS .

    ARITH_OP        reduce using rule 89 (assign -> lhs MINUS_MINUS .)
    BOOL_OP         reduce using rule 89 (assign -> lhs MINUS_MINUS .)
    COMMA           reduce using rule 89 (assign -> lhs MINUS_MINUS .)
    RIGHT_PAR       reduce using rule 89 (assign -> lhs MINUS_MINUS .)
    SEMICOLON       reduce using rule 89 (assign -> lhs MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 89 (assign -> lhs MINUS_MINUS .)


state 142

    (90) assign -> MINUS_MINUS lhs .
    (68) primary -> lhs .

    ARITH_OP        reduce using rule 90 (assign -> MINUS_MINUS lhs .)
    BOOL_OP         reduce using rule 90 (assign -> MINUS_MINUS lhs .)
    COMMA           reduce using rule 90 (assign -> MINUS_MINUS lhs .)
    RIGHT_PAR       reduce using rule 90 (assign -> MINUS_MINUS lhs .)
    SEMICOLON       reduce using rule 90 (assign -> MINUS_MINUS lhs .)
    RIGHT_BRACKET   reduce using rule 90 (assign -> MINUS_MINUS lhs .)
    DOT             reduce using rule 68 (primary -> lhs .)
    LEFT_BRACKET    reduce using rule 68 (primary -> lhs .)


state 143

    (88) assign -> PLUS_PLUS lhs .
    (68) primary -> lhs .

    ARITH_OP        reduce using rule 88 (assign -> PLUS_PLUS lhs .)
    BOOL_OP         reduce using rule 88 (assign -> PLUS_PLUS lhs .)
    COMMA           reduce using rule 88 (assign -> PLUS_PLUS lhs .)
    RIGHT_PAR       reduce using rule 88 (assign -> PLUS_PLUS lhs .)
    SEMICOLON       reduce using rule 88 (assign -> PLUS_PLUS lhs .)
    RIGHT_BRACKET   reduce using rule 88 (assign -> PLUS_PLUS lhs .)
    DOT             reduce using rule 68 (primary -> lhs .)
    LEFT_BRACKET    reduce using rule 68 (primary -> lhs .)


state 144

    (65) primary -> LEFT_PAR expr . RIGHT_PAR
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

    RIGHT_PAR       shift and go to state 163
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149


state 145

    (91) new_array -> NEW type . array_expr_plus array_empty_star
    (92) array_expr_plus -> . array_expr
    (93) array_expr_plus -> . array_expr array_expr_plus
    (94) array_expr -> . LEFT_BRACKET expr RIGHT_BRACKET

    LEFT_BRACKET    shift and go to state 166

    array_expr_plus                shift and go to state 164
    array_expr                     shift and go to state 165

state 146

    (66) primary -> NEW ID . LEFT_PAR RIGHT_PAR
    (67) primary -> NEW ID . LEFT_PAR arguments RIGHT_PAR
    (24) type -> ID .

    LEFT_PAR        shift and go to state 152
    LEFT_BRACKET    reduce using rule 24 (type -> ID .)


state 147

    (49) stmt -> RETURN expr_opt SEMICOLON .

    IF              reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    WHILE           reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    FOR             reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    RETURN          reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    BREAK           reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    CONTINUE        reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    SEMICOLON       reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    LEFT_BRACE      reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    PLUS_PLUS       reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    MINUS_MINUS     reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    INT             reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    FLOAT           reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    BOOLEAN         reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    ID              reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    THIS            reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    SUPER           reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    LEFT_PAR        reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    NEW             reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    INT_CONST       reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    FLOAT_CONST     reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    STRING_CONST    reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    NULL            reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    TRUE            reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    FALSE           reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    RIGHT_BRACE     reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)
    ELSE            reduce using rule 49 (stmt -> RETURN expr_opt SEMICOLON .)


state 148

    (83) expr -> expr ARITH_OP . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 167
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 149

    (84) expr -> expr BOOL_OP . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 168
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 150

    (85) expr -> UNARY_OP expr .
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for BOOL_OP resolved as shift
    SEMICOLON       reduce using rule 85 (expr -> UNARY_OP expr .)
    RIGHT_PAR       reduce using rule 85 (expr -> UNARY_OP expr .)
    RIGHT_BRACKET   reduce using rule 85 (expr -> UNARY_OP expr .)
    COMMA           reduce using rule 85 (expr -> UNARY_OP expr .)
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149

  ! ARITH_OP        [ reduce using rule 85 (expr -> UNARY_OP expr .) ]
  ! BOOL_OP         [ reduce using rule 85 (expr -> UNARY_OP expr .) ]


state 151

    (47) stmt -> WHILE LEFT_PAR expr . RIGHT_PAR stmt
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

    RIGHT_PAR       shift and go to state 169
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149


state 152

    (66) primary -> NEW ID LEFT_PAR . RIGHT_PAR
    (67) primary -> NEW ID LEFT_PAR . arguments RIGHT_PAR
    (70) arguments -> . expr more_expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    RIGHT_PAR       shift and go to state 171
    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 157
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    arguments                      shift and go to state 170
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 153

    (77) array_access -> primary LEFT_BRACKET expr . RIGHT_BRACKET
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

    RIGHT_BRACKET   shift and go to state 172
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149


state 154

    (75) field_access -> primary DOT ID .

    LEFT_PAR        reduce using rule 75 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 75 (field_access -> primary DOT ID .)
    ARITH_OP        reduce using rule 75 (field_access -> primary DOT ID .)
    BOOL_OP         reduce using rule 75 (field_access -> primary DOT ID .)
    DOT             reduce using rule 75 (field_access -> primary DOT ID .)
    LEFT_BRACKET    reduce using rule 75 (field_access -> primary DOT ID .)
    RIGHT_PAR       reduce using rule 75 (field_access -> primary DOT ID .)
    RIGHT_BRACKET   reduce using rule 75 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 75 (field_access -> primary DOT ID .)
    EQUALS          reduce using rule 75 (field_access -> primary DOT ID .)
    PLUS_PLUS       reduce using rule 75 (field_access -> primary DOT ID .)
    MINUS_MINUS     reduce using rule 75 (field_access -> primary DOT ID .)


state 155

    (79) method_invocation -> field_access LEFT_PAR arguments . RIGHT_PAR

    RIGHT_PAR       shift and go to state 173


state 156

    (78) method_invocation -> field_access LEFT_PAR RIGHT_PAR .

    DOT             reduce using rule 78 (method_invocation -> field_access LEFT_PAR RIGHT_PAR .)
    LEFT_BRACKET    reduce using rule 78 (method_invocation -> field_access LEFT_PAR RIGHT_PAR .)
    RIGHT_BRACKET   reduce using rule 78 (method_invocation -> field_access LEFT_PAR RIGHT_PAR .)
    ARITH_OP        reduce using rule 78 (method_invocation -> field_access LEFT_PAR RIGHT_PAR .)
    BOOL_OP         reduce using rule 78 (method_invocation -> field_access LEFT_PAR RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 78 (method_invocation -> field_access LEFT_PAR RIGHT_PAR .)
    SEMICOLON       reduce using rule 78 (method_invocation -> field_access LEFT_PAR RIGHT_PAR .)
    COMMA           reduce using rule 78 (method_invocation -> field_access LEFT_PAR RIGHT_PAR .)


state 157

    (70) arguments -> expr . more_expr
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr
    (71) more_expr -> . empty
    (72) more_expr -> . COMMA expr more_expr
    (2) empty -> .

    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149
    COMMA           shift and go to state 174
    RIGHT_PAR       reduce using rule 2 (empty -> .)

    empty                          shift and go to state 176
    more_expr                      shift and go to state 175

state 158

    (101) stmt_expr_opt -> stmt_expr .

    RIGHT_PAR       reduce using rule 101 (stmt_expr_opt -> stmt_expr .)
    SEMICOLON       reduce using rule 101 (stmt_expr_opt -> stmt_expr .)


state 159

    (48) stmt -> FOR LEFT_PAR stmt_expr_opt . SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt

    SEMICOLON       shift and go to state 177


state 160

    (100) stmt_expr_opt -> empty .

    RIGHT_PAR       reduce using rule 100 (stmt_expr_opt -> empty .)
    SEMICOLON       reduce using rule 100 (stmt_expr_opt -> empty .)


state 161

    (45) stmt -> IF LEFT_PAR expr . RIGHT_PAR stmt
    (46) stmt -> IF LEFT_PAR expr . RIGHT_PAR stmt ELSE stmt
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

    RIGHT_PAR       shift and go to state 178
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149


state 162

    (86) assign -> lhs EQUALS expr .
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for BOOL_OP resolved as shift
    COMMA           reduce using rule 86 (assign -> lhs EQUALS expr .)
    RIGHT_PAR       reduce using rule 86 (assign -> lhs EQUALS expr .)
    SEMICOLON       reduce using rule 86 (assign -> lhs EQUALS expr .)
    RIGHT_BRACKET   reduce using rule 86 (assign -> lhs EQUALS expr .)
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149

  ! ARITH_OP        [ reduce using rule 86 (assign -> lhs EQUALS expr .) ]
  ! BOOL_OP         [ reduce using rule 86 (assign -> lhs EQUALS expr .) ]


state 163

    (65) primary -> LEFT_PAR expr RIGHT_PAR .

    DOT             reduce using rule 65 (primary -> LEFT_PAR expr RIGHT_PAR .)
    LEFT_BRACKET    reduce using rule 65 (primary -> LEFT_PAR expr RIGHT_PAR .)
    ARITH_OP        reduce using rule 65 (primary -> LEFT_PAR expr RIGHT_PAR .)
    BOOL_OP         reduce using rule 65 (primary -> LEFT_PAR expr RIGHT_PAR .)
    COMMA           reduce using rule 65 (primary -> LEFT_PAR expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 65 (primary -> LEFT_PAR expr RIGHT_PAR .)
    RIGHT_BRACKET   reduce using rule 65 (primary -> LEFT_PAR expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 65 (primary -> LEFT_PAR expr RIGHT_PAR .)


state 164

    (91) new_array -> NEW type array_expr_plus . array_empty_star
    (95) array_empty_star -> . empty
    (96) array_empty_star -> . array_empty array_empty_star
    (2) empty -> .
    (97) array_empty -> . LEFT_BRACKET RIGHT_BRACKET

    ARITH_OP        reduce using rule 2 (empty -> .)
    BOOL_OP         reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    RIGHT_PAR       reduce using rule 2 (empty -> .)
    RIGHT_BRACKET   reduce using rule 2 (empty -> .)
    COMMA           reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 181

    array_empty_star               shift and go to state 179
    array_empty                    shift and go to state 180
    empty                          shift and go to state 182

state 165

    (92) array_expr_plus -> array_expr .
    (93) array_expr_plus -> array_expr . array_expr_plus
    (92) array_expr_plus -> . array_expr
    (93) array_expr_plus -> . array_expr array_expr_plus
    (94) array_expr -> . LEFT_BRACKET expr RIGHT_BRACKET

  ! shift/reduce conflict for LEFT_BRACKET resolved as shift
    ARITH_OP        reduce using rule 92 (array_expr_plus -> array_expr .)
    BOOL_OP         reduce using rule 92 (array_expr_plus -> array_expr .)
    SEMICOLON       reduce using rule 92 (array_expr_plus -> array_expr .)
    RIGHT_PAR       reduce using rule 92 (array_expr_plus -> array_expr .)
    RIGHT_BRACKET   reduce using rule 92 (array_expr_plus -> array_expr .)
    COMMA           reduce using rule 92 (array_expr_plus -> array_expr .)
    LEFT_BRACKET    shift and go to state 166

  ! LEFT_BRACKET    [ reduce using rule 92 (array_expr_plus -> array_expr .) ]

    array_expr                     shift and go to state 165
    array_expr_plus                shift and go to state 183

state 166

    (94) array_expr -> LEFT_BRACKET . expr RIGHT_BRACKET
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 184
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 167

    (83) expr -> expr ARITH_OP expr .
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for BOOL_OP resolved as shift
    SEMICOLON       reduce using rule 83 (expr -> expr ARITH_OP expr .)
    RIGHT_PAR       reduce using rule 83 (expr -> expr ARITH_OP expr .)
    RIGHT_BRACKET   reduce using rule 83 (expr -> expr ARITH_OP expr .)
    COMMA           reduce using rule 83 (expr -> expr ARITH_OP expr .)
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149

  ! ARITH_OP        [ reduce using rule 83 (expr -> expr ARITH_OP expr .) ]
  ! BOOL_OP         [ reduce using rule 83 (expr -> expr ARITH_OP expr .) ]


state 168

    (84) expr -> expr BOOL_OP expr .
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for BOOL_OP resolved as shift
    SEMICOLON       reduce using rule 84 (expr -> expr BOOL_OP expr .)
    RIGHT_PAR       reduce using rule 84 (expr -> expr BOOL_OP expr .)
    RIGHT_BRACKET   reduce using rule 84 (expr -> expr BOOL_OP expr .)
    COMMA           reduce using rule 84 (expr -> expr BOOL_OP expr .)
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149

  ! ARITH_OP        [ reduce using rule 84 (expr -> expr BOOL_OP expr .) ]
  ! BOOL_OP         [ reduce using rule 84 (expr -> expr BOOL_OP expr .) ]


state 169

    (47) stmt -> WHILE LEFT_PAR expr RIGHT_PAR . stmt
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt
    (46) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt
    (47) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (48) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (49) stmt -> . RETURN expr_opt SEMICOLON
    (50) stmt -> . stmt_expr SEMICOLON
    (51) stmt -> . BREAK SEMICOLON
    (52) stmt -> . CONTINUE SEMICOLON
    (53) stmt -> . block
    (54) stmt -> . var_decl
    (55) stmt -> . SEMICOLON
    (98) stmt_expr -> . assign
    (99) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (20) var_decl -> . type variables SEMICOLON
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 97
    WHILE           shift and go to state 78
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 100
    CONTINUE        shift and go to state 102
    SEMICOLON       shift and go to state 85
    LEFT_BRACE      shift and go to state 67
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 96
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 92
    array_access                   shift and go to state 81
    stmt_expr                      shift and go to state 87
    primary                        shift and go to state 84
    stmt                           shift and go to state 185
    literal                        shift and go to state 88
    lhs                            shift and go to state 103
    var_decl                       shift and go to state 99
    type                           shift and go to state 90
    method_invocation              shift and go to state 89
    assign                         shift and go to state 108
    block                          shift and go to state 109

state 170

    (67) primary -> NEW ID LEFT_PAR arguments . RIGHT_PAR

    RIGHT_PAR       shift and go to state 186


state 171

    (66) primary -> NEW ID LEFT_PAR RIGHT_PAR .

    DOT             reduce using rule 66 (primary -> NEW ID LEFT_PAR RIGHT_PAR .)
    LEFT_BRACKET    reduce using rule 66 (primary -> NEW ID LEFT_PAR RIGHT_PAR .)
    ARITH_OP        reduce using rule 66 (primary -> NEW ID LEFT_PAR RIGHT_PAR .)
    BOOL_OP         reduce using rule 66 (primary -> NEW ID LEFT_PAR RIGHT_PAR .)
    COMMA           reduce using rule 66 (primary -> NEW ID LEFT_PAR RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 66 (primary -> NEW ID LEFT_PAR RIGHT_PAR .)
    RIGHT_BRACKET   reduce using rule 66 (primary -> NEW ID LEFT_PAR RIGHT_PAR .)
    SEMICOLON       reduce using rule 66 (primary -> NEW ID LEFT_PAR RIGHT_PAR .)


state 172

    (77) array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .

    EQUALS          reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    PLUS_PLUS       reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    MINUS_MINUS     reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    DOT             reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    LEFT_BRACKET    reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    ARITH_OP        reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    BOOL_OP         reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    COMMA           reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_PAR       reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 77 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)


state 173

    (79) method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .

    DOT             reduce using rule 79 (method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .)
    LEFT_BRACKET    reduce using rule 79 (method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .)
    RIGHT_BRACKET   reduce using rule 79 (method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .)
    ARITH_OP        reduce using rule 79 (method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .)
    BOOL_OP         reduce using rule 79 (method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 79 (method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .)
    SEMICOLON       reduce using rule 79 (method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .)
    COMMA           reduce using rule 79 (method_invocation -> field_access LEFT_PAR arguments RIGHT_PAR .)


state 174

    (72) more_expr -> COMMA . expr more_expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    field_access                   shift and go to state 121
    expr                           shift and go to state 187
    primary                        shift and go to state 116
    array_access                   shift and go to state 81
    literal                        shift and go to state 88
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126

state 175

    (70) arguments -> expr more_expr .

    RIGHT_PAR       reduce using rule 70 (arguments -> expr more_expr .)


state 176

    (71) more_expr -> empty .

    RIGHT_PAR       reduce using rule 71 (more_expr -> empty .)


state 177

    (48) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON . expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (102) expr_opt -> . empty
    (103) expr_opt -> . expr
    (2) empty -> .
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . new_array
    (83) expr -> . expr ARITH_OP expr
    (84) expr -> . expr BOOL_OP expr
    (85) expr -> . UNARY_OP expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (91) new_array -> . NEW type array_expr_plus array_empty_star
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    SEMICOLON       reduce using rule 2 (empty -> .)
    UNARY_OP        shift and go to state 125
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 117
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98
    ID              shift and go to state 122

    new_array                      shift and go to state 115
    array_access                   shift and go to state 81
    field_access                   shift and go to state 121
    expr                           shift and go to state 123
    primary                        shift and go to state 116
    literal                        shift and go to state 88
    expr_opt                       shift and go to state 188
    lhs                            shift and go to state 124
    method_invocation              shift and go to state 119
    assign                         shift and go to state 126
    empty                          shift and go to state 120

state 178

    (45) stmt -> IF LEFT_PAR expr RIGHT_PAR . stmt
    (46) stmt -> IF LEFT_PAR expr RIGHT_PAR . stmt ELSE stmt
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt
    (46) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt
    (47) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (48) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (49) stmt -> . RETURN expr_opt SEMICOLON
    (50) stmt -> . stmt_expr SEMICOLON
    (51) stmt -> . BREAK SEMICOLON
    (52) stmt -> . CONTINUE SEMICOLON
    (53) stmt -> . block
    (54) stmt -> . var_decl
    (55) stmt -> . SEMICOLON
    (98) stmt_expr -> . assign
    (99) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (20) var_decl -> . type variables SEMICOLON
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 97
    WHILE           shift and go to state 78
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 100
    CONTINUE        shift and go to state 102
    SEMICOLON       shift and go to state 85
    LEFT_BRACE      shift and go to state 67
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 96
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 92
    array_access                   shift and go to state 81
    stmt_expr                      shift and go to state 87
    primary                        shift and go to state 84
    stmt                           shift and go to state 189
    literal                        shift and go to state 88
    lhs                            shift and go to state 103
    var_decl                       shift and go to state 99
    type                           shift and go to state 90
    method_invocation              shift and go to state 89
    assign                         shift and go to state 108
    block                          shift and go to state 109

state 179

    (91) new_array -> NEW type array_expr_plus array_empty_star .

    ARITH_OP        reduce using rule 91 (new_array -> NEW type array_expr_plus array_empty_star .)
    BOOL_OP         reduce using rule 91 (new_array -> NEW type array_expr_plus array_empty_star .)
    SEMICOLON       reduce using rule 91 (new_array -> NEW type array_expr_plus array_empty_star .)
    COMMA           reduce using rule 91 (new_array -> NEW type array_expr_plus array_empty_star .)
    RIGHT_PAR       reduce using rule 91 (new_array -> NEW type array_expr_plus array_empty_star .)
    RIGHT_BRACKET   reduce using rule 91 (new_array -> NEW type array_expr_plus array_empty_star .)


state 180

    (96) array_empty_star -> array_empty . array_empty_star
    (95) array_empty_star -> . empty
    (96) array_empty_star -> . array_empty array_empty_star
    (2) empty -> .
    (97) array_empty -> . LEFT_BRACKET RIGHT_BRACKET

    ARITH_OP        reduce using rule 2 (empty -> .)
    BOOL_OP         reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    RIGHT_PAR       reduce using rule 2 (empty -> .)
    RIGHT_BRACKET   reduce using rule 2 (empty -> .)
    COMMA           reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 181

    array_empty                    shift and go to state 180
    array_empty_star               shift and go to state 190
    empty                          shift and go to state 182

state 181

    (97) array_empty -> LEFT_BRACKET . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 191


state 182

    (95) array_empty_star -> empty .

    ARITH_OP        reduce using rule 95 (array_empty_star -> empty .)
    BOOL_OP         reduce using rule 95 (array_empty_star -> empty .)
    SEMICOLON       reduce using rule 95 (array_empty_star -> empty .)
    RIGHT_PAR       reduce using rule 95 (array_empty_star -> empty .)
    RIGHT_BRACKET   reduce using rule 95 (array_empty_star -> empty .)
    COMMA           reduce using rule 95 (array_empty_star -> empty .)


state 183

    (93) array_expr_plus -> array_expr array_expr_plus .

    LEFT_BRACKET    reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    ARITH_OP        reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    BOOL_OP         reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    SEMICOLON       reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    RIGHT_PAR       reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    RIGHT_BRACKET   reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    COMMA           reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)


state 184

    (94) array_expr -> LEFT_BRACKET expr . RIGHT_BRACKET
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr

    RIGHT_BRACKET   shift and go to state 192
    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149


state 185

    (47) stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .

    IF              reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    WHILE           reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    FOR             reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    RETURN          reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    BREAK           reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    CONTINUE        reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    SEMICOLON       reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    LEFT_BRACE      reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    PLUS_PLUS       reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    MINUS_MINUS     reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    INT             reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    FLOAT           reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    BOOLEAN         reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    ID              reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    THIS            reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    SUPER           reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    LEFT_PAR        reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    NEW             reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    INT_CONST       reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    FLOAT_CONST     reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    STRING_CONST    reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    NULL            reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    TRUE            reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    FALSE           reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    RIGHT_BRACE     reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    ELSE            reduce using rule 47 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)


state 186

    (67) primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .

    DOT             reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .)
    LEFT_BRACKET    reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .)
    ARITH_OP        reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .)
    BOOL_OP         reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .)
    COMMA           reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .)
    RIGHT_BRACKET   reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .)
    SEMICOLON       reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments RIGHT_PAR .)


state 187

    (72) more_expr -> COMMA expr . more_expr
    (83) expr -> expr . ARITH_OP expr
    (84) expr -> expr . BOOL_OP expr
    (71) more_expr -> . empty
    (72) more_expr -> . COMMA expr more_expr
    (2) empty -> .

    ARITH_OP        shift and go to state 148
    BOOL_OP         shift and go to state 149
    COMMA           shift and go to state 174
    RIGHT_PAR       reduce using rule 2 (empty -> .)

    empty                          shift and go to state 176
    more_expr                      shift and go to state 193

state 188

    (48) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt . SEMICOLON stmt_expr_opt RIGHT_PAR stmt

    SEMICOLON       shift and go to state 194


state 189

    (45) stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .
    (46) stmt -> IF LEFT_PAR expr RIGHT_PAR stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    WHILE           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    FOR             reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    RETURN          reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    BREAK           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    CONTINUE        reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    SEMICOLON       reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    LEFT_BRACE      reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    PLUS_PLUS       reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    MINUS_MINUS     reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    INT             reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    FLOAT           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    BOOLEAN         reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    ID              reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    THIS            reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    SUPER           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    LEFT_PAR        reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    NEW             reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    INT_CONST       reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    FLOAT_CONST     reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    STRING_CONST    reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    NULL            reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    TRUE            reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    FALSE           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    RIGHT_BRACE     reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .)
    ELSE            shift and go to state 195

  ! ELSE            [ reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt .) ]


state 190

    (96) array_empty_star -> array_empty array_empty_star .

    ARITH_OP        reduce using rule 96 (array_empty_star -> array_empty array_empty_star .)
    BOOL_OP         reduce using rule 96 (array_empty_star -> array_empty array_empty_star .)
    SEMICOLON       reduce using rule 96 (array_empty_star -> array_empty array_empty_star .)
    RIGHT_PAR       reduce using rule 96 (array_empty_star -> array_empty array_empty_star .)
    RIGHT_BRACKET   reduce using rule 96 (array_empty_star -> array_empty array_empty_star .)
    COMMA           reduce using rule 96 (array_empty_star -> array_empty array_empty_star .)


state 191

    (97) array_empty -> LEFT_BRACKET RIGHT_BRACKET .

    LEFT_BRACKET    reduce using rule 97 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    ARITH_OP        reduce using rule 97 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    BOOL_OP         reduce using rule 97 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 97 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    RIGHT_PAR       reduce using rule 97 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 97 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    COMMA           reduce using rule 97 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)


state 192

    (94) array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .

    LEFT_BRACKET    reduce using rule 94 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    ARITH_OP        reduce using rule 94 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    BOOL_OP         reduce using rule 94 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 94 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_PAR       reduce using rule 94 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 94 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    COMMA           reduce using rule 94 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)


state 193

    (72) more_expr -> COMMA expr more_expr .

    RIGHT_PAR       reduce using rule 72 (more_expr -> COMMA expr more_expr .)


state 194

    (48) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON . stmt_expr_opt RIGHT_PAR stmt
    (100) stmt_expr_opt -> . empty
    (101) stmt_expr_opt -> . stmt_expr
    (2) empty -> .
    (98) stmt_expr -> . assign
    (99) stmt_expr -> . method_invocation
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    RIGHT_PAR       reduce using rule 2 (empty -> .)
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    ID              shift and go to state 122
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 92
    primary                        shift and go to state 84
    stmt_expr_opt                  shift and go to state 196
    stmt_expr                      shift and go to state 158
    literal                        shift and go to state 88
    lhs                            shift and go to state 103
    method_invocation              shift and go to state 89
    array_access                   shift and go to state 81
    assign                         shift and go to state 108
    empty                          shift and go to state 160

state 195

    (46) stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE . stmt
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt
    (46) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt
    (47) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (48) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (49) stmt -> . RETURN expr_opt SEMICOLON
    (50) stmt -> . stmt_expr SEMICOLON
    (51) stmt -> . BREAK SEMICOLON
    (52) stmt -> . CONTINUE SEMICOLON
    (53) stmt -> . block
    (54) stmt -> . var_decl
    (55) stmt -> . SEMICOLON
    (98) stmt_expr -> . assign
    (99) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (20) var_decl -> . type variables SEMICOLON
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 97
    WHILE           shift and go to state 78
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 100
    CONTINUE        shift and go to state 102
    SEMICOLON       shift and go to state 85
    LEFT_BRACE      shift and go to state 67
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 96
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 92
    array_access                   shift and go to state 81
    stmt_expr                      shift and go to state 87
    primary                        shift and go to state 84
    stmt                           shift and go to state 197
    literal                        shift and go to state 88
    lhs                            shift and go to state 103
    var_decl                       shift and go to state 99
    type                           shift and go to state 90
    method_invocation              shift and go to state 89
    assign                         shift and go to state 108
    block                          shift and go to state 109

state 196

    (48) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt . RIGHT_PAR stmt

    RIGHT_PAR       shift and go to state 198


state 197

    (46) stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .

    IF              reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    WHILE           reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    FOR             reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    RETURN          reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    BREAK           reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    CONTINUE        reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    SEMICOLON       reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    LEFT_BRACE      reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    PLUS_PLUS       reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    MINUS_MINUS     reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    INT             reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    FLOAT           reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    BOOLEAN         reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    ID              reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    THIS            reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    SUPER           reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    LEFT_PAR        reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    NEW             reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    INT_CONST       reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    FLOAT_CONST     reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    STRING_CONST    reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    NULL            reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    TRUE            reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    FALSE           reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    RIGHT_BRACE     reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)
    ELSE            reduce using rule 46 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt .)


state 198

    (48) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR . stmt
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt
    (46) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt ELSE stmt
    (47) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (48) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (49) stmt -> . RETURN expr_opt SEMICOLON
    (50) stmt -> . stmt_expr SEMICOLON
    (51) stmt -> . BREAK SEMICOLON
    (52) stmt -> . CONTINUE SEMICOLON
    (53) stmt -> . block
    (54) stmt -> . var_decl
    (55) stmt -> . SEMICOLON
    (98) stmt_expr -> . assign
    (99) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (20) var_decl -> . type variables SEMICOLON
    (86) assign -> . lhs EQUALS expr
    (87) assign -> . lhs PLUS_PLUS
    (88) assign -> . PLUS_PLUS lhs
    (89) assign -> . lhs MINUS_MINUS
    (90) assign -> . MINUS_MINUS lhs
    (78) method_invocation -> . field_access LEFT_PAR RIGHT_PAR
    (79) method_invocation -> . field_access LEFT_PAR arguments RIGHT_PAR
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (73) lhs -> . field_access
    (74) lhs -> . array_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (77) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . LEFT_PAR expr RIGHT_PAR
    (66) primary -> . NEW ID LEFT_PAR RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 97
    WHILE           shift and go to state 78
    FOR             shift and go to state 93
    RETURN          shift and go to state 77
    BREAK           shift and go to state 100
    CONTINUE        shift and go to state 102
    SEMICOLON       shift and go to state 85
    LEFT_BRACE      shift and go to state 67
    PLUS_PLUS       shift and go to state 105
    MINUS_MINUS     shift and go to state 104
    INT             shift and go to state 29
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 32
    ID              shift and go to state 96
    THIS            shift and go to state 101
    SUPER           shift and go to state 107
    LEFT_PAR        shift and go to state 106
    NEW             shift and go to state 79
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 110
    STRING_CONST    shift and go to state 82
    NULL            shift and go to state 80
    TRUE            shift and go to state 86
    FALSE           shift and go to state 98

    field_access                   shift and go to state 92
    array_access                   shift and go to state 81
    primary                        shift and go to state 84
    stmt                           shift and go to state 199
    stmt_expr                      shift and go to state 87
    literal                        shift and go to state 88
    lhs                            shift and go to state 103
    var_decl                       shift and go to state 99
    type                           shift and go to state 90
    method_invocation              shift and go to state 89
    assign                         shift and go to state 108
    block                          shift and go to state 109

state 199

    (48) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .

    IF              reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    WHILE           reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    FOR             reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    RETURN          reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    BREAK           reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    CONTINUE        reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    SEMICOLON       reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    LEFT_BRACE      reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    PLUS_PLUS       reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    MINUS_MINUS     reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    INT             reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    FLOAT           reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    BOOLEAN         reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    ID              reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    THIS            reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    SUPER           reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    LEFT_PAR        reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    NEW             reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    INT_CONST       reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    FLOAT_CONST     reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    STRING_CONST    reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    NULL            reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    TRUE            reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    FALSE           reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    RIGHT_BRACE     reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    ELSE            reduce using rule 48 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ARITH_OP in state 150 resolved as shift
WARNING: shift/reduce conflict for BOOL_OP in state 150 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for BOOL_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for LEFT_BRACKET in state 165 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 167 resolved as shift
WARNING: shift/reduce conflict for BOOL_OP in state 167 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 168 resolved as shift
WARNING: shift/reduce conflict for BOOL_OP in state 168 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 189 resolved as shift
