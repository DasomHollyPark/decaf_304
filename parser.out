Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO

Grammar

Rule 0     S' -> program
Rule 1     program -> class_decl_star
Rule 2     empty -> <empty>
Rule 3     class_decl_star -> empty
Rule 4     class_decl_star -> class_decl class_decl_star
Rule 5     class_decl -> CLASS ID extends_opt LEFT_BRACE class_body_decl_plus RIGHT_BRACE
Rule 6     extends_opt -> empty
Rule 7     extends_opt -> extends
Rule 8     extends -> EXTENDS ID
Rule 9     class_body_decl_plus -> class_body_decl
Rule 10    class_body_decl_plus -> class_body_decl class_body_decl_plus
Rule 11    class_body_decl -> field_decl
Rule 12    class_body_decl -> method_decl
Rule 13    class_body_decl -> constructor_decl
Rule 14    field_decl -> modifier var_decl
Rule 15    modifier -> empty
Rule 16    modifier -> PUBLIC
Rule 17    modifier -> PRIVATE
Rule 18    modifier -> PUBLIC STATIC
Rule 19    modifier -> PRIVATE STATIC
Rule 20    modifier -> STATIC
Rule 21    var_decl -> type variables SEMICOLON
Rule 22    type -> INT
Rule 23    type -> FLOAT
Rule 24    type -> BOOLEAN
Rule 25    type -> ID
Rule 26    variables -> variable more_variables
Rule 27    more_variables -> empty
Rule 28    more_variables -> COMMA variable more_variables
Rule 29    variable -> ID array_dim_star
Rule 30    array_dim_star -> empty
Rule 31    array_dim_star -> array_dim array_dim_star
Rule 32    array_dim -> LEFT_BRACKET RIGHT_BRACKET
Rule 33    method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block
Rule 34    method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block
Rule 35    constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block
Rule 36    formals_opt -> empty
Rule 37    formals_opt -> formals
Rule 38    formals -> formal_param more_formals
Rule 39    more_formals -> empty
Rule 40    more_formals -> COMMA formal_param more_formals
Rule 41    formal_param -> type variable
Rule 42    block -> LEFT_BRACE stmt_star RIGHT_BRACE
Rule 43    stmt_star -> empty
Rule 44    stmt_star -> stmt stmt_star
Rule 45    stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt
Rule 46    stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt
Rule 47    stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
Rule 48    stmt -> RETURN expr_opt SEMICOLON
Rule 49    stmt -> stmt_expr SEMICOLON
Rule 50    stmt -> BREAK SEMICOLON
Rule 51    stmt -> CONTINUE SEMICOLON
Rule 52    stmt -> block
Rule 53    stmt -> var_decl
Rule 54    stmt -> SEMICOLON
Rule 55    else_opt -> empty
Rule 56    else_opt -> ELSE stmt
Rule 57    literal -> INT_CONST
Rule 58    literal -> FLOAT_CONST
Rule 59    literal -> STRING_CONST
Rule 60    literal -> NULL
Rule 61    literal -> TRUE
Rule 62    literal -> FALSE
Rule 63    primary -> literal
Rule 64    primary -> THIS
Rule 65    primary -> SUPER
Rule 66    primary -> LEFT_PAR expr RIGHT_PAR
Rule 67    primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR
Rule 68    primary -> lhs
Rule 69    primary -> method_invocation
Rule 70    arguments_opt -> empty
Rule 71    arguments_opt -> arguments
Rule 72    arguments -> expr more_expr
Rule 73    more_expr -> empty
Rule 74    more_expr -> COMMA expr more_expr
Rule 75    lhs -> field_access
Rule 76    lhs -> array_access
Rule 77    field_access -> primary DOT ID
Rule 78    field_access -> ID
Rule 79    array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET
Rule 80    method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR
Rule 81    expr -> primary
Rule 82    expr -> assign
Rule 83    expr -> new_array
Rule 84    expr -> expr ARITH_OP expr
Rule 85    expr -> expr BOOL_OP expr
Rule 86    expr -> UNARY_OP expr
Rule 87    assign -> lhs EQUALS expr
Rule 88    assign -> lhs PLUS_PLUS
Rule 89    assign -> PLUS_PLUS lhs
Rule 90    assign -> lhs MINUS_MINUS
Rule 91    assign -> MINUS_MINUS lhs
Rule 92    new_array -> NEW type array_expr_plus array_empty_star
Rule 93    array_expr_plus -> array_expr array_expr_plus
Rule 94    array_expr_plus -> array_expr
Rule 95    array_expr -> LEFT_BRACKET expr RIGHT_BRACKET
Rule 96    array_empty_star -> empty
Rule 97    array_empty_star -> array_empty array_empty_star
Rule 98    array_empty -> LEFT_BRACKET RIGHT_BRACKET
Rule 99    stmt_expr -> assign
Rule 100   stmt_expr -> method_invocation
Rule 101   stmt_expr_opt -> empty
Rule 102   stmt_expr_opt -> stmt_expr
Rule 103   expr_opt -> empty
Rule 104   expr_opt -> expr

Terminals, with rules where they appear

ARITH_OP             : 84
BOOLEAN              : 24
BOOL_OP              : 85
BREAK                : 50
CLASS                : 5
COMMA                : 28 40 74
CONTINUE             : 51
DO                   : 
DOT                  : 77
ELSE                 : 56
EQUALS               : 87
EXTENDS              : 8
FALSE                : 62
FLOAT                : 23
FLOAT_CONST          : 58
FOR                  : 47
ID                   : 5 8 25 29 33 34 35 67 77 78
IF                   : 45
INT                  : 22
INT_CONST            : 57
LEFT_BRACE           : 5 42
LEFT_BRACKET         : 32 79 95 98
LEFT_PAR             : 33 34 35 45 46 47 66 67 80
MINUS_MINUS          : 90 91
NEW                  : 67 92
NULL                 : 60
PLUS_PLUS            : 88 89
PRIVATE              : 17 19
PUBLIC               : 16 18
RETURN               : 48
RIGHT_BRACE          : 5 42
RIGHT_BRACKET        : 32 79 95 98
RIGHT_PAR            : 33 34 35 45 46 47 66 67 80
SEMICOLON            : 21 47 47 48 49 50 51 54
STATIC               : 18 19 20
STRING_CONST         : 59
SUPER                : 65
THIS                 : 64
TRUE                 : 61
UNARY_OP             : 86
VOID                 : 34
WHILE                : 46
error                : 

Nonterminals, with rules where they appear

arguments            : 71
arguments_opt        : 67 80
array_access         : 76
array_dim            : 31
array_dim_star       : 29 31
array_empty          : 97
array_empty_star     : 92 97
array_expr           : 93 94
array_expr_plus      : 92 93
assign               : 82 99
block                : 33 34 35 52
class_body_decl      : 9 10
class_body_decl_plus : 5 10
class_decl           : 4
class_decl_star      : 1 4
constructor_decl     : 13
else_opt             : 45
empty                : 3 6 15 27 30 36 39 43 55 70 73 96 101 103
expr                 : 45 46 66 72 74 79 84 84 85 85 86 87 95 104
expr_opt             : 47 48
extends              : 7
extends_opt          : 5
field_access         : 75 80
field_decl           : 11
formal_param         : 38 40
formals              : 37
formals_opt          : 33 34 35
lhs                  : 68 87 88 89 90 91
literal              : 63
method_decl          : 12
method_invocation    : 69 100
modifier             : 14 33 34 35
more_expr            : 72 74
more_formals         : 38 40
more_variables       : 26 28
new_array            : 83
primary              : 77 79 81
program              : 0
stmt                 : 44 45 46 47 56
stmt_expr            : 49 102
stmt_expr_opt        : 47 47
stmt_star            : 42 44
type                 : 21 33 41 92
var_decl             : 14 53
variable             : 26 28 41
variables            : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_decl_star
    (3) class_decl_star -> . empty
    (4) class_decl_star -> . class_decl class_decl_star
    (2) empty -> .
    (5) class_decl -> . CLASS ID extends_opt LEFT_BRACE class_body_decl_plus RIGHT_BRACE

    $end            reduce using rule 2 (empty -> .)
    CLASS           shift and go to state 3

    program                        shift and go to state 1
    class_decl                     shift and go to state 2
    class_decl_star                shift and go to state 5
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (4) class_decl_star -> class_decl . class_decl_star
    (3) class_decl_star -> . empty
    (4) class_decl_star -> . class_decl class_decl_star
    (2) empty -> .
    (5) class_decl -> . CLASS ID extends_opt LEFT_BRACE class_body_decl_plus RIGHT_BRACE

    $end            reduce using rule 2 (empty -> .)
    CLASS           shift and go to state 3

    class_decl                     shift and go to state 2
    empty                          shift and go to state 4
    class_decl_star                shift and go to state 6

state 3

    (5) class_decl -> CLASS . ID extends_opt LEFT_BRACE class_body_decl_plus RIGHT_BRACE

    ID              shift and go to state 7


state 4

    (3) class_decl_star -> empty .

    $end            reduce using rule 3 (class_decl_star -> empty .)


state 5

    (1) program -> class_decl_star .

    $end            reduce using rule 1 (program -> class_decl_star .)


state 6

    (4) class_decl_star -> class_decl class_decl_star .

    $end            reduce using rule 4 (class_decl_star -> class_decl class_decl_star .)


state 7

    (5) class_decl -> CLASS ID . extends_opt LEFT_BRACE class_body_decl_plus RIGHT_BRACE
    (6) extends_opt -> . empty
    (7) extends_opt -> . extends
    (2) empty -> .
    (8) extends -> . EXTENDS ID

    LEFT_BRACE      reduce using rule 2 (empty -> .)
    EXTENDS         shift and go to state 8

    extends_opt                    shift and go to state 9
    extends                        shift and go to state 10
    empty                          shift and go to state 11

state 8

    (8) extends -> EXTENDS . ID

    ID              shift and go to state 12


state 9

    (5) class_decl -> CLASS ID extends_opt . LEFT_BRACE class_body_decl_plus RIGHT_BRACE

    LEFT_BRACE      shift and go to state 13


state 10

    (7) extends_opt -> extends .

    LEFT_BRACE      reduce using rule 7 (extends_opt -> extends .)


state 11

    (6) extends_opt -> empty .

    LEFT_BRACE      reduce using rule 6 (extends_opt -> empty .)


state 12

    (8) extends -> EXTENDS ID .

    LEFT_BRACE      reduce using rule 8 (extends -> EXTENDS ID .)


state 13

    (5) class_decl -> CLASS ID extends_opt LEFT_BRACE . class_body_decl_plus RIGHT_BRACE
    (9) class_body_decl_plus -> . class_body_decl
    (10) class_body_decl_plus -> . class_body_decl class_body_decl_plus
    (11) class_body_decl -> . field_decl
    (12) class_body_decl -> . method_decl
    (13) class_body_decl -> . constructor_decl
    (14) field_decl -> . modifier var_decl
    (33) method_decl -> . modifier type ID LEFT_PAR formals_opt RIGHT_PAR block
    (34) method_decl -> . modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block
    (35) constructor_decl -> . modifier ID LEFT_PAR formals_opt RIGHT_PAR block
    (15) modifier -> . empty
    (16) modifier -> . PUBLIC
    (17) modifier -> . PRIVATE
    (18) modifier -> . PUBLIC STATIC
    (19) modifier -> . PRIVATE STATIC
    (20) modifier -> . STATIC
    (2) empty -> .

    PUBLIC          shift and go to state 23
    PRIVATE         shift and go to state 17
    STATIC          shift and go to state 15
    VOID            reduce using rule 2 (empty -> .)
    ID              reduce using rule 2 (empty -> .)
    INT             reduce using rule 2 (empty -> .)
    FLOAT           reduce using rule 2 (empty -> .)
    BOOLEAN         reduce using rule 2 (empty -> .)

    class_body_decl                shift and go to state 16
    field_decl                     shift and go to state 20
    constructor_decl               shift and go to state 14
    method_decl                    shift and go to state 21
    empty                          shift and go to state 19
    class_body_decl_plus           shift and go to state 18
    modifier                       shift and go to state 22

state 14

    (13) class_body_decl -> constructor_decl .

    PUBLIC          reduce using rule 13 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 13 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 13 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 13 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 13 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 13 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 13 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 13 (class_body_decl -> constructor_decl .)
    RIGHT_BRACE     reduce using rule 13 (class_body_decl -> constructor_decl .)


state 15

    (20) modifier -> STATIC .

    VOID            reduce using rule 20 (modifier -> STATIC .)
    ID              reduce using rule 20 (modifier -> STATIC .)
    INT             reduce using rule 20 (modifier -> STATIC .)
    FLOAT           reduce using rule 20 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 20 (modifier -> STATIC .)


state 16

    (9) class_body_decl_plus -> class_body_decl .
    (10) class_body_decl_plus -> class_body_decl . class_body_decl_plus
    (9) class_body_decl_plus -> . class_body_decl
    (10) class_body_decl_plus -> . class_body_decl class_body_decl_plus
    (11) class_body_decl -> . field_decl
    (12) class_body_decl -> . method_decl
    (13) class_body_decl -> . constructor_decl
    (14) field_decl -> . modifier var_decl
    (33) method_decl -> . modifier type ID LEFT_PAR formals_opt RIGHT_PAR block
    (34) method_decl -> . modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block
    (35) constructor_decl -> . modifier ID LEFT_PAR formals_opt RIGHT_PAR block
    (15) modifier -> . empty
    (16) modifier -> . PUBLIC
    (17) modifier -> . PRIVATE
    (18) modifier -> . PUBLIC STATIC
    (19) modifier -> . PRIVATE STATIC
    (20) modifier -> . STATIC
    (2) empty -> .

    RIGHT_BRACE     reduce using rule 9 (class_body_decl_plus -> class_body_decl .)
    PUBLIC          shift and go to state 23
    PRIVATE         shift and go to state 17
    STATIC          shift and go to state 15
    VOID            reduce using rule 2 (empty -> .)
    ID              reduce using rule 2 (empty -> .)
    INT             reduce using rule 2 (empty -> .)
    FLOAT           reduce using rule 2 (empty -> .)
    BOOLEAN         reduce using rule 2 (empty -> .)

    class_body_decl                shift and go to state 16
    field_decl                     shift and go to state 20
    constructor_decl               shift and go to state 14
    method_decl                    shift and go to state 21
    empty                          shift and go to state 19
    class_body_decl_plus           shift and go to state 24
    modifier                       shift and go to state 22

state 17

    (17) modifier -> PRIVATE .
    (19) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 17 (modifier -> PRIVATE .)
    ID              reduce using rule 17 (modifier -> PRIVATE .)
    INT             reduce using rule 17 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 17 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 17 (modifier -> PRIVATE .)
    STATIC          shift and go to state 25


state 18

    (5) class_decl -> CLASS ID extends_opt LEFT_BRACE class_body_decl_plus . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 26


state 19

    (15) modifier -> empty .

    VOID            reduce using rule 15 (modifier -> empty .)
    ID              reduce using rule 15 (modifier -> empty .)
    INT             reduce using rule 15 (modifier -> empty .)
    FLOAT           reduce using rule 15 (modifier -> empty .)
    BOOLEAN         reduce using rule 15 (modifier -> empty .)


state 20

    (11) class_body_decl -> field_decl .

    PUBLIC          reduce using rule 11 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 11 (class_body_decl -> field_decl .)
    VOID            reduce using rule 11 (class_body_decl -> field_decl .)
    ID              reduce using rule 11 (class_body_decl -> field_decl .)
    INT             reduce using rule 11 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 11 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl -> field_decl .)
    RIGHT_BRACE     reduce using rule 11 (class_body_decl -> field_decl .)


state 21

    (12) class_body_decl -> method_decl .

    PUBLIC          reduce using rule 12 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 12 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 12 (class_body_decl -> method_decl .)
    VOID            reduce using rule 12 (class_body_decl -> method_decl .)
    ID              reduce using rule 12 (class_body_decl -> method_decl .)
    INT             reduce using rule 12 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 12 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 12 (class_body_decl -> method_decl .)
    RIGHT_BRACE     reduce using rule 12 (class_body_decl -> method_decl .)


state 22

    (14) field_decl -> modifier . var_decl
    (33) method_decl -> modifier . type ID LEFT_PAR formals_opt RIGHT_PAR block
    (34) method_decl -> modifier . VOID ID LEFT_PAR formals_opt RIGHT_PAR block
    (35) constructor_decl -> modifier . ID LEFT_PAR formals_opt RIGHT_PAR block
    (21) var_decl -> . type variables SEMICOLON
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID

    VOID            shift and go to state 29
    ID              shift and go to state 33
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31

    var_decl                       shift and go to state 30
    type                           shift and go to state 32

state 23

    (16) modifier -> PUBLIC .
    (18) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 16 (modifier -> PUBLIC .)
    ID              reduce using rule 16 (modifier -> PUBLIC .)
    INT             reduce using rule 16 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 16 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 16 (modifier -> PUBLIC .)
    STATIC          shift and go to state 34


state 24

    (10) class_body_decl_plus -> class_body_decl class_body_decl_plus .

    RIGHT_BRACE     reduce using rule 10 (class_body_decl_plus -> class_body_decl class_body_decl_plus .)


state 25

    (19) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 19 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 19 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 19 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 19 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 19 (modifier -> PRIVATE STATIC .)


state 26

    (5) class_decl -> CLASS ID extends_opt LEFT_BRACE class_body_decl_plus RIGHT_BRACE .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID extends_opt LEFT_BRACE class_body_decl_plus RIGHT_BRACE .)
    $end            reduce using rule 5 (class_decl -> CLASS ID extends_opt LEFT_BRACE class_body_decl_plus RIGHT_BRACE .)


state 27

    (23) type -> FLOAT .

    ID              reduce using rule 23 (type -> FLOAT .)
    LEFT_BRACKET    reduce using rule 23 (type -> FLOAT .)


state 28

    (22) type -> INT .

    ID              reduce using rule 22 (type -> INT .)
    LEFT_BRACKET    reduce using rule 22 (type -> INT .)


state 29

    (34) method_decl -> modifier VOID . ID LEFT_PAR formals_opt RIGHT_PAR block

    ID              shift and go to state 35


state 30

    (14) field_decl -> modifier var_decl .

    PUBLIC          reduce using rule 14 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 14 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 14 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 14 (field_decl -> modifier var_decl .)
    ID              reduce using rule 14 (field_decl -> modifier var_decl .)
    INT             reduce using rule 14 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 14 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 14 (field_decl -> modifier var_decl .)
    RIGHT_BRACE     reduce using rule 14 (field_decl -> modifier var_decl .)


state 31

    (24) type -> BOOLEAN .

    ID              reduce using rule 24 (type -> BOOLEAN .)
    LEFT_BRACKET    reduce using rule 24 (type -> BOOLEAN .)


state 32

    (33) method_decl -> modifier type . ID LEFT_PAR formals_opt RIGHT_PAR block
    (21) var_decl -> type . variables SEMICOLON
    (26) variables -> . variable more_variables
    (29) variable -> . ID array_dim_star

    ID              shift and go to state 38

    variables                      shift and go to state 36
    variable                       shift and go to state 37

state 33

    (35) constructor_decl -> modifier ID . LEFT_PAR formals_opt RIGHT_PAR block
    (25) type -> ID .

    LEFT_PAR        shift and go to state 39
    ID              reduce using rule 25 (type -> ID .)


state 34

    (18) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 18 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 18 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 18 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 18 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 18 (modifier -> PUBLIC STATIC .)


state 35

    (34) method_decl -> modifier VOID ID . LEFT_PAR formals_opt RIGHT_PAR block

    LEFT_PAR        shift and go to state 40


state 36

    (21) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 41


state 37

    (26) variables -> variable . more_variables
    (27) more_variables -> . empty
    (28) more_variables -> . COMMA variable more_variables
    (2) empty -> .

    COMMA           shift and go to state 43
    SEMICOLON       reduce using rule 2 (empty -> .)

    more_variables                 shift and go to state 42
    empty                          shift and go to state 44

state 38

    (33) method_decl -> modifier type ID . LEFT_PAR formals_opt RIGHT_PAR block
    (29) variable -> ID . array_dim_star
    (30) array_dim_star -> . empty
    (31) array_dim_star -> . array_dim array_dim_star
    (2) empty -> .
    (32) array_dim -> . LEFT_BRACKET RIGHT_BRACKET

    LEFT_PAR        shift and go to state 46
    COMMA           reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 49

    array_dim                      shift and go to state 45
    array_dim_star                 shift and go to state 47
    empty                          shift and go to state 48

state 39

    (35) constructor_decl -> modifier ID LEFT_PAR . formals_opt RIGHT_PAR block
    (36) formals_opt -> . empty
    (37) formals_opt -> . formals
    (2) empty -> .
    (38) formals -> . formal_param more_formals
    (41) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID

    RIGHT_PAR       reduce using rule 2 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 54

    formal_param                   shift and go to state 50
    formals_opt                    shift and go to state 52
    type                           shift and go to state 53
    empty                          shift and go to state 51
    formals                        shift and go to state 55

state 40

    (34) method_decl -> modifier VOID ID LEFT_PAR . formals_opt RIGHT_PAR block
    (36) formals_opt -> . empty
    (37) formals_opt -> . formals
    (2) empty -> .
    (38) formals -> . formal_param more_formals
    (41) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID

    RIGHT_PAR       reduce using rule 2 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 54

    formal_param                   shift and go to state 50
    formals_opt                    shift and go to state 56
    type                           shift and go to state 53
    empty                          shift and go to state 51
    formals                        shift and go to state 55

state 41

    (21) var_decl -> type variables SEMICOLON .

    IF              reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    LEFT_BRACE      reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    PLUS_PLUS       reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    MINUS_MINUS     reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    LEFT_PAR        reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    INT_CONST       reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    FLOAT_CONST     reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    STRING_CONST    reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    RIGHT_BRACE     reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 21 (var_decl -> type variables SEMICOLON .)


state 42

    (26) variables -> variable more_variables .

    SEMICOLON       reduce using rule 26 (variables -> variable more_variables .)


state 43

    (28) more_variables -> COMMA . variable more_variables
    (29) variable -> . ID array_dim_star

    ID              shift and go to state 58

    variable                       shift and go to state 57

state 44

    (27) more_variables -> empty .

    SEMICOLON       reduce using rule 27 (more_variables -> empty .)


state 45

    (31) array_dim_star -> array_dim . array_dim_star
    (30) array_dim_star -> . empty
    (31) array_dim_star -> . array_dim array_dim_star
    (2) empty -> .
    (32) array_dim -> . LEFT_BRACKET RIGHT_BRACKET

    COMMA           reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    RIGHT_PAR       reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 49

    array_dim                      shift and go to state 45
    array_dim_star                 shift and go to state 59
    empty                          shift and go to state 48

state 46

    (33) method_decl -> modifier type ID LEFT_PAR . formals_opt RIGHT_PAR block
    (36) formals_opt -> . empty
    (37) formals_opt -> . formals
    (2) empty -> .
    (38) formals -> . formal_param more_formals
    (41) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID

    RIGHT_PAR       reduce using rule 2 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 54

    formal_param                   shift and go to state 50
    formals_opt                    shift and go to state 60
    type                           shift and go to state 53
    empty                          shift and go to state 51
    formals                        shift and go to state 55

state 47

    (29) variable -> ID array_dim_star .

    COMMA           reduce using rule 29 (variable -> ID array_dim_star .)
    RIGHT_PAR       reduce using rule 29 (variable -> ID array_dim_star .)
    SEMICOLON       reduce using rule 29 (variable -> ID array_dim_star .)


state 48

    (30) array_dim_star -> empty .

    COMMA           reduce using rule 30 (array_dim_star -> empty .)
    SEMICOLON       reduce using rule 30 (array_dim_star -> empty .)
    RIGHT_PAR       reduce using rule 30 (array_dim_star -> empty .)


state 49

    (32) array_dim -> LEFT_BRACKET . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 61


state 50

    (38) formals -> formal_param . more_formals
    (39) more_formals -> . empty
    (40) more_formals -> . COMMA formal_param more_formals
    (2) empty -> .

    COMMA           shift and go to state 62
    RIGHT_PAR       reduce using rule 2 (empty -> .)

    empty                          shift and go to state 63
    more_formals                   shift and go to state 64

state 51

    (36) formals_opt -> empty .

    RIGHT_PAR       reduce using rule 36 (formals_opt -> empty .)


state 52

    (35) constructor_decl -> modifier ID LEFT_PAR formals_opt . RIGHT_PAR block

    RIGHT_PAR       shift and go to state 65


state 53

    (41) formal_param -> type . variable
    (29) variable -> . ID array_dim_star

    ID              shift and go to state 58

    variable                       shift and go to state 66

state 54

    (25) type -> ID .

    ID              reduce using rule 25 (type -> ID .)


state 55

    (37) formals_opt -> formals .

    RIGHT_PAR       reduce using rule 37 (formals_opt -> formals .)


state 56

    (34) method_decl -> modifier VOID ID LEFT_PAR formals_opt . RIGHT_PAR block

    RIGHT_PAR       shift and go to state 67


state 57

    (28) more_variables -> COMMA variable . more_variables
    (27) more_variables -> . empty
    (28) more_variables -> . COMMA variable more_variables
    (2) empty -> .

    COMMA           shift and go to state 43
    SEMICOLON       reduce using rule 2 (empty -> .)

    more_variables                 shift and go to state 68
    empty                          shift and go to state 44

state 58

    (29) variable -> ID . array_dim_star
    (30) array_dim_star -> . empty
    (31) array_dim_star -> . array_dim array_dim_star
    (2) empty -> .
    (32) array_dim -> . LEFT_BRACKET RIGHT_BRACKET

    COMMA           reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    RIGHT_PAR       reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 49

    array_dim                      shift and go to state 45
    array_dim_star                 shift and go to state 47
    empty                          shift and go to state 48

state 59

    (31) array_dim_star -> array_dim array_dim_star .

    COMMA           reduce using rule 31 (array_dim_star -> array_dim array_dim_star .)
    SEMICOLON       reduce using rule 31 (array_dim_star -> array_dim array_dim_star .)
    RIGHT_PAR       reduce using rule 31 (array_dim_star -> array_dim array_dim_star .)


state 60

    (33) method_decl -> modifier type ID LEFT_PAR formals_opt . RIGHT_PAR block

    RIGHT_PAR       shift and go to state 69


state 61

    (32) array_dim -> LEFT_BRACKET RIGHT_BRACKET .

    LEFT_BRACKET    reduce using rule 32 (array_dim -> LEFT_BRACKET RIGHT_BRACKET .)
    COMMA           reduce using rule 32 (array_dim -> LEFT_BRACKET RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 32 (array_dim -> LEFT_BRACKET RIGHT_BRACKET .)
    RIGHT_PAR       reduce using rule 32 (array_dim -> LEFT_BRACKET RIGHT_BRACKET .)


state 62

    (40) more_formals -> COMMA . formal_param more_formals
    (41) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID

    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 54

    formal_param                   shift and go to state 70
    type                           shift and go to state 53

state 63

    (39) more_formals -> empty .

    RIGHT_PAR       reduce using rule 39 (more_formals -> empty .)


state 64

    (38) formals -> formal_param more_formals .

    RIGHT_PAR       reduce using rule 38 (formals -> formal_param more_formals .)


state 65

    (35) constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 72

    block                          shift and go to state 71

state 66

    (41) formal_param -> type variable .

    COMMA           reduce using rule 41 (formal_param -> type variable .)
    RIGHT_PAR       reduce using rule 41 (formal_param -> type variable .)


state 67

    (34) method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 72

    block                          shift and go to state 73

state 68

    (28) more_variables -> COMMA variable more_variables .

    SEMICOLON       reduce using rule 28 (more_variables -> COMMA variable more_variables .)


state 69

    (33) method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR . block
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE

    LEFT_BRACE      shift and go to state 72

    block                          shift and go to state 74

state 70

    (40) more_formals -> COMMA formal_param . more_formals
    (39) more_formals -> . empty
    (40) more_formals -> . COMMA formal_param more_formals
    (2) empty -> .

    COMMA           shift and go to state 62
    RIGHT_PAR       reduce using rule 2 (empty -> .)

    empty                          shift and go to state 63
    more_formals                   shift and go to state 75

state 71

    (35) constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .

    PUBLIC          reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)
    PRIVATE         reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)
    STATIC          reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)
    VOID            reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)
    ID              reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)
    INT             reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)
    FLOAT           reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)
    BOOLEAN         reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 35 (constructor_decl -> modifier ID LEFT_PAR formals_opt RIGHT_PAR block .)


state 72

    (42) block -> LEFT_BRACE . stmt_star RIGHT_BRACE
    (43) stmt_star -> . empty
    (44) stmt_star -> . stmt stmt_star
    (2) empty -> .
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt else_opt
    (46) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (47) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (48) stmt -> . RETURN expr_opt SEMICOLON
    (49) stmt -> . stmt_expr SEMICOLON
    (50) stmt -> . BREAK SEMICOLON
    (51) stmt -> . CONTINUE SEMICOLON
    (52) stmt -> . block
    (53) stmt -> . var_decl
    (54) stmt -> . SEMICOLON
    (99) stmt_expr -> . assign
    (100) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (21) var_decl -> . type variables SEMICOLON
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 2 (empty -> .)
    IF              shift and go to state 96
    WHILE           shift and go to state 77
    FOR             shift and go to state 91
    RETURN          shift and go to state 76
    BREAK           shift and go to state 99
    CONTINUE        shift and go to state 101
    SEMICOLON       shift and go to state 83
    LEFT_BRACE      shift and go to state 72
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 95
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 90
    array_access                   shift and go to state 80
    stmt_expr                      shift and go to state 85
    var_decl                       shift and go to state 98
    primary                        shift and go to state 93
    stmt                           shift and go to state 92
    literal                        shift and go to state 86
    lhs                            shift and go to state 102
    block                          shift and go to state 108
    type                           shift and go to state 88
    method_invocation              shift and go to state 87
    stmt_star                      shift and go to state 94
    assign                         shift and go to state 107
    empty                          shift and go to state 89

state 73

    (34) method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .

    PUBLIC          reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)
    PRIVATE         reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)
    STATIC          reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)
    VOID            reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)
    ID              reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)
    INT             reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)
    FLOAT           reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)
    BOOLEAN         reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 34 (method_decl -> modifier VOID ID LEFT_PAR formals_opt RIGHT_PAR block .)


state 74

    (33) method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .

    PUBLIC          reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)
    PRIVATE         reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)
    STATIC          reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)
    VOID            reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)
    ID              reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)
    INT             reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)
    FLOAT           reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)
    BOOLEAN         reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)
    RIGHT_BRACE     reduce using rule 33 (method_decl -> modifier type ID LEFT_PAR formals_opt RIGHT_PAR block .)


state 75

    (40) more_formals -> COMMA formal_param more_formals .

    RIGHT_PAR       reduce using rule 40 (more_formals -> COMMA formal_param more_formals .)


state 76

    (48) stmt -> RETURN . expr_opt SEMICOLON
    (103) expr_opt -> . empty
    (104) expr_opt -> . expr
    (2) empty -> .
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    SEMICOLON       reduce using rule 2 (empty -> .)
    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 118
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    expr_opt                       shift and go to state 113
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121
    empty                          shift and go to state 115

state 77

    (46) stmt -> WHILE . LEFT_PAR expr RIGHT_PAR stmt

    LEFT_PAR        shift and go to state 122


state 78

    (67) primary -> NEW . ID LEFT_PAR arguments_opt RIGHT_PAR

    ID              shift and go to state 123


state 79

    (60) literal -> NULL .

    DOT             reduce using rule 60 (literal -> NULL .)
    LEFT_BRACKET    reduce using rule 60 (literal -> NULL .)
    ARITH_OP        reduce using rule 60 (literal -> NULL .)
    BOOL_OP         reduce using rule 60 (literal -> NULL .)
    SEMICOLON       reduce using rule 60 (literal -> NULL .)
    RIGHT_PAR       reduce using rule 60 (literal -> NULL .)
    COMMA           reduce using rule 60 (literal -> NULL .)
    RIGHT_BRACKET   reduce using rule 60 (literal -> NULL .)


state 80

    (76) lhs -> array_access .

    EQUALS          reduce using rule 76 (lhs -> array_access .)
    PLUS_PLUS       reduce using rule 76 (lhs -> array_access .)
    MINUS_MINUS     reduce using rule 76 (lhs -> array_access .)
    DOT             reduce using rule 76 (lhs -> array_access .)
    LEFT_BRACKET    reduce using rule 76 (lhs -> array_access .)
    RIGHT_BRACKET   reduce using rule 76 (lhs -> array_access .)
    ARITH_OP        reduce using rule 76 (lhs -> array_access .)
    BOOL_OP         reduce using rule 76 (lhs -> array_access .)
    SEMICOLON       reduce using rule 76 (lhs -> array_access .)
    RIGHT_PAR       reduce using rule 76 (lhs -> array_access .)
    COMMA           reduce using rule 76 (lhs -> array_access .)


state 81

    (59) literal -> STRING_CONST .

    DOT             reduce using rule 59 (literal -> STRING_CONST .)
    LEFT_BRACKET    reduce using rule 59 (literal -> STRING_CONST .)
    ARITH_OP        reduce using rule 59 (literal -> STRING_CONST .)
    BOOL_OP         reduce using rule 59 (literal -> STRING_CONST .)
    SEMICOLON       reduce using rule 59 (literal -> STRING_CONST .)
    RIGHT_PAR       reduce using rule 59 (literal -> STRING_CONST .)
    COMMA           reduce using rule 59 (literal -> STRING_CONST .)
    RIGHT_BRACKET   reduce using rule 59 (literal -> STRING_CONST .)


state 82

    (57) literal -> INT_CONST .

    DOT             reduce using rule 57 (literal -> INT_CONST .)
    LEFT_BRACKET    reduce using rule 57 (literal -> INT_CONST .)
    ARITH_OP        reduce using rule 57 (literal -> INT_CONST .)
    BOOL_OP         reduce using rule 57 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 57 (literal -> INT_CONST .)
    RIGHT_PAR       reduce using rule 57 (literal -> INT_CONST .)
    COMMA           reduce using rule 57 (literal -> INT_CONST .)
    RIGHT_BRACKET   reduce using rule 57 (literal -> INT_CONST .)


state 83

    (54) stmt -> SEMICOLON .

    IF              reduce using rule 54 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 54 (stmt -> SEMICOLON .)
    FOR             reduce using rule 54 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 54 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 54 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 54 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 54 (stmt -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 54 (stmt -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 54 (stmt -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 54 (stmt -> SEMICOLON .)
    INT             reduce using rule 54 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 54 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 54 (stmt -> SEMICOLON .)
    ID              reduce using rule 54 (stmt -> SEMICOLON .)
    THIS            reduce using rule 54 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 54 (stmt -> SEMICOLON .)
    LEFT_PAR        reduce using rule 54 (stmt -> SEMICOLON .)
    NEW             reduce using rule 54 (stmt -> SEMICOLON .)
    INT_CONST       reduce using rule 54 (stmt -> SEMICOLON .)
    FLOAT_CONST     reduce using rule 54 (stmt -> SEMICOLON .)
    STRING_CONST    reduce using rule 54 (stmt -> SEMICOLON .)
    NULL            reduce using rule 54 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 54 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 54 (stmt -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 54 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 54 (stmt -> SEMICOLON .)


state 84

    (61) literal -> TRUE .

    DOT             reduce using rule 61 (literal -> TRUE .)
    LEFT_BRACKET    reduce using rule 61 (literal -> TRUE .)
    ARITH_OP        reduce using rule 61 (literal -> TRUE .)
    BOOL_OP         reduce using rule 61 (literal -> TRUE .)
    SEMICOLON       reduce using rule 61 (literal -> TRUE .)
    RIGHT_PAR       reduce using rule 61 (literal -> TRUE .)
    COMMA           reduce using rule 61 (literal -> TRUE .)
    RIGHT_BRACKET   reduce using rule 61 (literal -> TRUE .)


state 85

    (49) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 124


state 86

    (63) primary -> literal .

    DOT             reduce using rule 63 (primary -> literal .)
    LEFT_BRACKET    reduce using rule 63 (primary -> literal .)
    RIGHT_PAR       reduce using rule 63 (primary -> literal .)
    ARITH_OP        reduce using rule 63 (primary -> literal .)
    BOOL_OP         reduce using rule 63 (primary -> literal .)
    RIGHT_BRACKET   reduce using rule 63 (primary -> literal .)
    COMMA           reduce using rule 63 (primary -> literal .)
    SEMICOLON       reduce using rule 63 (primary -> literal .)


state 87

    (100) stmt_expr -> method_invocation .
    (69) primary -> method_invocation .

    SEMICOLON       reduce using rule 100 (stmt_expr -> method_invocation .)
    RIGHT_PAR       reduce using rule 100 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 69 (primary -> method_invocation .)
    LEFT_BRACKET    reduce using rule 69 (primary -> method_invocation .)


state 88

    (21) var_decl -> type . variables SEMICOLON
    (26) variables -> . variable more_variables
    (29) variable -> . ID array_dim_star

    ID              shift and go to state 58

    variable                       shift and go to state 37
    variables                      shift and go to state 36

state 89

    (43) stmt_star -> empty .

    RIGHT_BRACE     reduce using rule 43 (stmt_star -> empty .)


state 90

    (80) method_invocation -> field_access . LEFT_PAR arguments_opt RIGHT_PAR
    (75) lhs -> field_access .

    LEFT_PAR        shift and go to state 125
    EQUALS          reduce using rule 75 (lhs -> field_access .)
    PLUS_PLUS       reduce using rule 75 (lhs -> field_access .)
    MINUS_MINUS     reduce using rule 75 (lhs -> field_access .)
    DOT             reduce using rule 75 (lhs -> field_access .)
    LEFT_BRACKET    reduce using rule 75 (lhs -> field_access .)


state 91

    (47) stmt -> FOR . LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt

    LEFT_PAR        shift and go to state 126


state 92

    (44) stmt_star -> stmt . stmt_star
    (43) stmt_star -> . empty
    (44) stmt_star -> . stmt stmt_star
    (2) empty -> .
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt else_opt
    (46) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (47) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (48) stmt -> . RETURN expr_opt SEMICOLON
    (49) stmt -> . stmt_expr SEMICOLON
    (50) stmt -> . BREAK SEMICOLON
    (51) stmt -> . CONTINUE SEMICOLON
    (52) stmt -> . block
    (53) stmt -> . var_decl
    (54) stmt -> . SEMICOLON
    (99) stmt_expr -> . assign
    (100) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (21) var_decl -> . type variables SEMICOLON
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 2 (empty -> .)
    IF              shift and go to state 96
    WHILE           shift and go to state 77
    FOR             shift and go to state 91
    RETURN          shift and go to state 76
    BREAK           shift and go to state 99
    CONTINUE        shift and go to state 101
    SEMICOLON       shift and go to state 83
    LEFT_BRACE      shift and go to state 72
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 95
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 90
    array_access                   shift and go to state 80
    stmt_expr                      shift and go to state 85
    var_decl                       shift and go to state 98
    primary                        shift and go to state 93
    stmt                           shift and go to state 92
    literal                        shift and go to state 86
    lhs                            shift and go to state 102
    block                          shift and go to state 108
    type                           shift and go to state 88
    method_invocation              shift and go to state 87
    stmt_star                      shift and go to state 127
    assign                         shift and go to state 107
    empty                          shift and go to state 89

state 93

    (77) field_access -> primary . DOT ID
    (79) array_access -> primary . LEFT_BRACKET expr RIGHT_BRACKET

    DOT             shift and go to state 129
    LEFT_BRACKET    shift and go to state 128


state 94

    (42) block -> LEFT_BRACE stmt_star . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 130


state 95

    (25) type -> ID .
    (78) field_access -> ID .

    ID              reduce using rule 25 (type -> ID .)
    LEFT_PAR        reduce using rule 78 (field_access -> ID .)
    EQUALS          reduce using rule 78 (field_access -> ID .)
    PLUS_PLUS       reduce using rule 78 (field_access -> ID .)
    MINUS_MINUS     reduce using rule 78 (field_access -> ID .)
    DOT             reduce using rule 78 (field_access -> ID .)
    LEFT_BRACKET    reduce using rule 78 (field_access -> ID .)


state 96

    (45) stmt -> IF . LEFT_PAR expr RIGHT_PAR stmt else_opt

    LEFT_PAR        shift and go to state 131


state 97

    (62) literal -> FALSE .

    DOT             reduce using rule 62 (literal -> FALSE .)
    LEFT_BRACKET    reduce using rule 62 (literal -> FALSE .)
    ARITH_OP        reduce using rule 62 (literal -> FALSE .)
    BOOL_OP         reduce using rule 62 (literal -> FALSE .)
    SEMICOLON       reduce using rule 62 (literal -> FALSE .)
    RIGHT_PAR       reduce using rule 62 (literal -> FALSE .)
    COMMA           reduce using rule 62 (literal -> FALSE .)
    RIGHT_BRACKET   reduce using rule 62 (literal -> FALSE .)


state 98

    (53) stmt -> var_decl .

    IF              reduce using rule 53 (stmt -> var_decl .)
    WHILE           reduce using rule 53 (stmt -> var_decl .)
    FOR             reduce using rule 53 (stmt -> var_decl .)
    RETURN          reduce using rule 53 (stmt -> var_decl .)
    BREAK           reduce using rule 53 (stmt -> var_decl .)
    CONTINUE        reduce using rule 53 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 53 (stmt -> var_decl .)
    LEFT_BRACE      reduce using rule 53 (stmt -> var_decl .)
    PLUS_PLUS       reduce using rule 53 (stmt -> var_decl .)
    MINUS_MINUS     reduce using rule 53 (stmt -> var_decl .)
    INT             reduce using rule 53 (stmt -> var_decl .)
    FLOAT           reduce using rule 53 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 53 (stmt -> var_decl .)
    ID              reduce using rule 53 (stmt -> var_decl .)
    THIS            reduce using rule 53 (stmt -> var_decl .)
    SUPER           reduce using rule 53 (stmt -> var_decl .)
    LEFT_PAR        reduce using rule 53 (stmt -> var_decl .)
    NEW             reduce using rule 53 (stmt -> var_decl .)
    INT_CONST       reduce using rule 53 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 53 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 53 (stmt -> var_decl .)
    NULL            reduce using rule 53 (stmt -> var_decl .)
    TRUE            reduce using rule 53 (stmt -> var_decl .)
    FALSE           reduce using rule 53 (stmt -> var_decl .)
    RIGHT_BRACE     reduce using rule 53 (stmt -> var_decl .)
    ELSE            reduce using rule 53 (stmt -> var_decl .)


state 99

    (50) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 132


state 100

    (64) primary -> THIS .

    DOT             reduce using rule 64 (primary -> THIS .)
    LEFT_BRACKET    reduce using rule 64 (primary -> THIS .)
    RIGHT_PAR       reduce using rule 64 (primary -> THIS .)
    ARITH_OP        reduce using rule 64 (primary -> THIS .)
    BOOL_OP         reduce using rule 64 (primary -> THIS .)
    RIGHT_BRACKET   reduce using rule 64 (primary -> THIS .)
    COMMA           reduce using rule 64 (primary -> THIS .)
    SEMICOLON       reduce using rule 64 (primary -> THIS .)


state 101

    (51) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 133


state 102

    (87) assign -> lhs . EQUALS expr
    (88) assign -> lhs . PLUS_PLUS
    (90) assign -> lhs . MINUS_MINUS
    (68) primary -> lhs .

    EQUALS          shift and go to state 134
    PLUS_PLUS       shift and go to state 135
    MINUS_MINUS     shift and go to state 136
    DOT             reduce using rule 68 (primary -> lhs .)
    LEFT_BRACKET    reduce using rule 68 (primary -> lhs .)


state 103

    (91) assign -> MINUS_MINUS . lhs
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR

    ID              shift and go to state 117
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 116
    primary                        shift and go to state 93
    literal                        shift and go to state 86
    lhs                            shift and go to state 137
    method_invocation              shift and go to state 114
    array_access                   shift and go to state 80

state 104

    (89) assign -> PLUS_PLUS . lhs
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR

    ID              shift and go to state 117
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 116
    primary                        shift and go to state 93
    literal                        shift and go to state 86
    lhs                            shift and go to state 138
    method_invocation              shift and go to state 114
    array_access                   shift and go to state 80

state 105

    (66) primary -> LEFT_PAR . expr RIGHT_PAR
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 139
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 106

    (65) primary -> SUPER .

    DOT             reduce using rule 65 (primary -> SUPER .)
    LEFT_BRACKET    reduce using rule 65 (primary -> SUPER .)
    RIGHT_PAR       reduce using rule 65 (primary -> SUPER .)
    ARITH_OP        reduce using rule 65 (primary -> SUPER .)
    BOOL_OP         reduce using rule 65 (primary -> SUPER .)
    RIGHT_BRACKET   reduce using rule 65 (primary -> SUPER .)
    COMMA           reduce using rule 65 (primary -> SUPER .)
    SEMICOLON       reduce using rule 65 (primary -> SUPER .)


state 107

    (99) stmt_expr -> assign .

    SEMICOLON       reduce using rule 99 (stmt_expr -> assign .)
    RIGHT_PAR       reduce using rule 99 (stmt_expr -> assign .)


state 108

    (52) stmt -> block .

    IF              reduce using rule 52 (stmt -> block .)
    WHILE           reduce using rule 52 (stmt -> block .)
    FOR             reduce using rule 52 (stmt -> block .)
    RETURN          reduce using rule 52 (stmt -> block .)
    BREAK           reduce using rule 52 (stmt -> block .)
    CONTINUE        reduce using rule 52 (stmt -> block .)
    SEMICOLON       reduce using rule 52 (stmt -> block .)
    LEFT_BRACE      reduce using rule 52 (stmt -> block .)
    PLUS_PLUS       reduce using rule 52 (stmt -> block .)
    MINUS_MINUS     reduce using rule 52 (stmt -> block .)
    INT             reduce using rule 52 (stmt -> block .)
    FLOAT           reduce using rule 52 (stmt -> block .)
    BOOLEAN         reduce using rule 52 (stmt -> block .)
    ID              reduce using rule 52 (stmt -> block .)
    THIS            reduce using rule 52 (stmt -> block .)
    SUPER           reduce using rule 52 (stmt -> block .)
    LEFT_PAR        reduce using rule 52 (stmt -> block .)
    NEW             reduce using rule 52 (stmt -> block .)
    INT_CONST       reduce using rule 52 (stmt -> block .)
    FLOAT_CONST     reduce using rule 52 (stmt -> block .)
    STRING_CONST    reduce using rule 52 (stmt -> block .)
    NULL            reduce using rule 52 (stmt -> block .)
    TRUE            reduce using rule 52 (stmt -> block .)
    FALSE           reduce using rule 52 (stmt -> block .)
    RIGHT_BRACE     reduce using rule 52 (stmt -> block .)
    ELSE            reduce using rule 52 (stmt -> block .)


state 109

    (58) literal -> FLOAT_CONST .

    DOT             reduce using rule 58 (literal -> FLOAT_CONST .)
    LEFT_BRACKET    reduce using rule 58 (literal -> FLOAT_CONST .)
    ARITH_OP        reduce using rule 58 (literal -> FLOAT_CONST .)
    BOOL_OP         reduce using rule 58 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 58 (literal -> FLOAT_CONST .)
    RIGHT_PAR       reduce using rule 58 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 58 (literal -> FLOAT_CONST .)
    RIGHT_BRACKET   reduce using rule 58 (literal -> FLOAT_CONST .)


state 110

    (83) expr -> new_array .

    RIGHT_BRACKET   reduce using rule 83 (expr -> new_array .)
    ARITH_OP        reduce using rule 83 (expr -> new_array .)
    BOOL_OP         reduce using rule 83 (expr -> new_array .)
    SEMICOLON       reduce using rule 83 (expr -> new_array .)
    RIGHT_PAR       reduce using rule 83 (expr -> new_array .)
    COMMA           reduce using rule 83 (expr -> new_array .)


state 111

    (81) expr -> primary .
    (77) field_access -> primary . DOT ID
    (79) array_access -> primary . LEFT_BRACKET expr RIGHT_BRACKET

    RIGHT_BRACKET   reduce using rule 81 (expr -> primary .)
    ARITH_OP        reduce using rule 81 (expr -> primary .)
    BOOL_OP         reduce using rule 81 (expr -> primary .)
    SEMICOLON       reduce using rule 81 (expr -> primary .)
    RIGHT_PAR       reduce using rule 81 (expr -> primary .)
    COMMA           reduce using rule 81 (expr -> primary .)
    DOT             shift and go to state 129
    LEFT_BRACKET    shift and go to state 128


state 112

    (67) primary -> NEW . ID LEFT_PAR arguments_opt RIGHT_PAR
    (92) new_array -> NEW . type array_expr_plus array_empty_star
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID

    ID              shift and go to state 141
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31

    type                           shift and go to state 140

state 113

    (48) stmt -> RETURN expr_opt . SEMICOLON

    SEMICOLON       shift and go to state 142


state 114

    (69) primary -> method_invocation .

    DOT             reduce using rule 69 (primary -> method_invocation .)
    LEFT_BRACKET    reduce using rule 69 (primary -> method_invocation .)
    RIGHT_PAR       reduce using rule 69 (primary -> method_invocation .)
    ARITH_OP        reduce using rule 69 (primary -> method_invocation .)
    BOOL_OP         reduce using rule 69 (primary -> method_invocation .)
    RIGHT_BRACKET   reduce using rule 69 (primary -> method_invocation .)
    COMMA           reduce using rule 69 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 69 (primary -> method_invocation .)


state 115

    (103) expr_opt -> empty .

    SEMICOLON       reduce using rule 103 (expr_opt -> empty .)


state 116

    (75) lhs -> field_access .
    (80) method_invocation -> field_access . LEFT_PAR arguments_opt RIGHT_PAR

    EQUALS          reduce using rule 75 (lhs -> field_access .)
    PLUS_PLUS       reduce using rule 75 (lhs -> field_access .)
    MINUS_MINUS     reduce using rule 75 (lhs -> field_access .)
    DOT             reduce using rule 75 (lhs -> field_access .)
    LEFT_BRACKET    reduce using rule 75 (lhs -> field_access .)
    RIGHT_BRACKET   reduce using rule 75 (lhs -> field_access .)
    ARITH_OP        reduce using rule 75 (lhs -> field_access .)
    BOOL_OP         reduce using rule 75 (lhs -> field_access .)
    SEMICOLON       reduce using rule 75 (lhs -> field_access .)
    RIGHT_PAR       reduce using rule 75 (lhs -> field_access .)
    COMMA           reduce using rule 75 (lhs -> field_access .)
    LEFT_PAR        shift and go to state 125


state 117

    (78) field_access -> ID .

    LEFT_PAR        reduce using rule 78 (field_access -> ID .)
    EQUALS          reduce using rule 78 (field_access -> ID .)
    PLUS_PLUS       reduce using rule 78 (field_access -> ID .)
    MINUS_MINUS     reduce using rule 78 (field_access -> ID .)
    DOT             reduce using rule 78 (field_access -> ID .)
    LEFT_BRACKET    reduce using rule 78 (field_access -> ID .)
    RIGHT_PAR       reduce using rule 78 (field_access -> ID .)
    ARITH_OP        reduce using rule 78 (field_access -> ID .)
    BOOL_OP         reduce using rule 78 (field_access -> ID .)
    SEMICOLON       reduce using rule 78 (field_access -> ID .)
    RIGHT_BRACKET   reduce using rule 78 (field_access -> ID .)
    COMMA           reduce using rule 78 (field_access -> ID .)


state 118

    (104) expr_opt -> expr .
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

    SEMICOLON       reduce using rule 104 (expr_opt -> expr .)
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144


state 119

    (68) primary -> lhs .
    (87) assign -> lhs . EQUALS expr
    (88) assign -> lhs . PLUS_PLUS
    (90) assign -> lhs . MINUS_MINUS

    DOT             reduce using rule 68 (primary -> lhs .)
    LEFT_BRACKET    reduce using rule 68 (primary -> lhs .)
    RIGHT_PAR       reduce using rule 68 (primary -> lhs .)
    ARITH_OP        reduce using rule 68 (primary -> lhs .)
    BOOL_OP         reduce using rule 68 (primary -> lhs .)
    RIGHT_BRACKET   reduce using rule 68 (primary -> lhs .)
    COMMA           reduce using rule 68 (primary -> lhs .)
    SEMICOLON       reduce using rule 68 (primary -> lhs .)
    EQUALS          shift and go to state 134
    PLUS_PLUS       shift and go to state 135
    MINUS_MINUS     shift and go to state 136


state 120

    (86) expr -> UNARY_OP . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 145
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 121

    (82) expr -> assign .

    RIGHT_BRACKET   reduce using rule 82 (expr -> assign .)
    ARITH_OP        reduce using rule 82 (expr -> assign .)
    BOOL_OP         reduce using rule 82 (expr -> assign .)
    SEMICOLON       reduce using rule 82 (expr -> assign .)
    RIGHT_PAR       reduce using rule 82 (expr -> assign .)
    COMMA           reduce using rule 82 (expr -> assign .)


state 122

    (46) stmt -> WHILE LEFT_PAR . expr RIGHT_PAR stmt
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 146
    primary                        shift and go to state 111
    literal                        shift and go to state 86
    array_access                   shift and go to state 80
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 123

    (67) primary -> NEW ID . LEFT_PAR arguments_opt RIGHT_PAR

    LEFT_PAR        shift and go to state 147


state 124

    (49) stmt -> stmt_expr SEMICOLON .

    IF              reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    LEFT_BRACE      reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    LEFT_PAR        reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    RIGHT_BRACE     reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 49 (stmt -> stmt_expr SEMICOLON .)


state 125

    (80) method_invocation -> field_access LEFT_PAR . arguments_opt RIGHT_PAR
    (70) arguments_opt -> . empty
    (71) arguments_opt -> . arguments
    (2) empty -> .
    (72) arguments -> . expr more_expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    RIGHT_PAR       reduce using rule 2 (empty -> .)
    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    field_access                   shift and go to state 116
    new_array                      shift and go to state 110
    expr                           shift and go to state 151
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    arguments                      shift and go to state 148
    arguments_opt                  shift and go to state 150
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121
    empty                          shift and go to state 149

state 126

    (47) stmt -> FOR LEFT_PAR . stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (101) stmt_expr_opt -> . empty
    (102) stmt_expr_opt -> . stmt_expr
    (2) empty -> .
    (99) stmt_expr -> . assign
    (100) stmt_expr -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    SEMICOLON       reduce using rule 2 (empty -> .)
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    ID              shift and go to state 117
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 90
    primary                        shift and go to state 93
    stmt_expr_opt                  shift and go to state 153
    stmt_expr                      shift and go to state 152
    literal                        shift and go to state 86
    lhs                            shift and go to state 102
    method_invocation              shift and go to state 87
    array_access                   shift and go to state 80
    assign                         shift and go to state 107
    empty                          shift and go to state 154

state 127

    (44) stmt_star -> stmt stmt_star .

    RIGHT_BRACE     reduce using rule 44 (stmt_star -> stmt stmt_star .)


state 128

    (79) array_access -> primary LEFT_BRACKET . expr RIGHT_BRACKET
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 155
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 129

    (77) field_access -> primary DOT . ID

    ID              shift and go to state 156


state 130

    (42) block -> LEFT_BRACE stmt_star RIGHT_BRACE .

    IF              reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    WHILE           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    FOR             reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    RETURN          reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    BREAK           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    CONTINUE        reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    SEMICOLON       reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    PLUS_PLUS       reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    MINUS_MINUS     reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    INT             reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    FLOAT           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    BOOLEAN         reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    ID              reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    THIS            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    SUPER           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    LEFT_PAR        reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    NEW             reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    INT_CONST       reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    FLOAT_CONST     reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    STRING_CONST    reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    NULL            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    TRUE            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    FALSE           reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    ELSE            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    PUBLIC          reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    PRIVATE         reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    STATIC          reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)
    VOID            reduce using rule 42 (block -> LEFT_BRACE stmt_star RIGHT_BRACE .)


state 131

    (45) stmt -> IF LEFT_PAR . expr RIGHT_PAR stmt else_opt
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 157
    primary                        shift and go to state 111
    literal                        shift and go to state 86
    array_access                   shift and go to state 80
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 132

    (50) stmt -> BREAK SEMICOLON .

    IF              reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    LEFT_BRACE      reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    PLUS_PLUS       reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    MINUS_MINUS     reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    LEFT_PAR        reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    STRING_CONST    reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    RIGHT_BRACE     reduce using rule 50 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 50 (stmt -> BREAK SEMICOLON .)


state 133

    (51) stmt -> CONTINUE SEMICOLON .

    IF              reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    LEFT_BRACE      reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    PLUS_PLUS       reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    MINUS_MINUS     reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    LEFT_PAR        reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    STRING_CONST    reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    RIGHT_BRACE     reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 51 (stmt -> CONTINUE SEMICOLON .)


state 134

    (87) assign -> lhs EQUALS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 158
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 135

    (88) assign -> lhs PLUS_PLUS .

    ARITH_OP        reduce using rule 88 (assign -> lhs PLUS_PLUS .)
    BOOL_OP         reduce using rule 88 (assign -> lhs PLUS_PLUS .)
    COMMA           reduce using rule 88 (assign -> lhs PLUS_PLUS .)
    RIGHT_PAR       reduce using rule 88 (assign -> lhs PLUS_PLUS .)
    SEMICOLON       reduce using rule 88 (assign -> lhs PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 88 (assign -> lhs PLUS_PLUS .)


state 136

    (90) assign -> lhs MINUS_MINUS .

    ARITH_OP        reduce using rule 90 (assign -> lhs MINUS_MINUS .)
    BOOL_OP         reduce using rule 90 (assign -> lhs MINUS_MINUS .)
    COMMA           reduce using rule 90 (assign -> lhs MINUS_MINUS .)
    RIGHT_PAR       reduce using rule 90 (assign -> lhs MINUS_MINUS .)
    SEMICOLON       reduce using rule 90 (assign -> lhs MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 90 (assign -> lhs MINUS_MINUS .)


state 137

    (91) assign -> MINUS_MINUS lhs .
    (68) primary -> lhs .

    ARITH_OP        reduce using rule 91 (assign -> MINUS_MINUS lhs .)
    BOOL_OP         reduce using rule 91 (assign -> MINUS_MINUS lhs .)
    COMMA           reduce using rule 91 (assign -> MINUS_MINUS lhs .)
    RIGHT_PAR       reduce using rule 91 (assign -> MINUS_MINUS lhs .)
    SEMICOLON       reduce using rule 91 (assign -> MINUS_MINUS lhs .)
    RIGHT_BRACKET   reduce using rule 91 (assign -> MINUS_MINUS lhs .)
    DOT             reduce using rule 68 (primary -> lhs .)
    LEFT_BRACKET    reduce using rule 68 (primary -> lhs .)


state 138

    (89) assign -> PLUS_PLUS lhs .
    (68) primary -> lhs .

    ARITH_OP        reduce using rule 89 (assign -> PLUS_PLUS lhs .)
    BOOL_OP         reduce using rule 89 (assign -> PLUS_PLUS lhs .)
    COMMA           reduce using rule 89 (assign -> PLUS_PLUS lhs .)
    RIGHT_PAR       reduce using rule 89 (assign -> PLUS_PLUS lhs .)
    SEMICOLON       reduce using rule 89 (assign -> PLUS_PLUS lhs .)
    RIGHT_BRACKET   reduce using rule 89 (assign -> PLUS_PLUS lhs .)
    DOT             reduce using rule 68 (primary -> lhs .)
    LEFT_BRACKET    reduce using rule 68 (primary -> lhs .)


state 139

    (66) primary -> LEFT_PAR expr . RIGHT_PAR
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

    RIGHT_PAR       shift and go to state 159
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144


state 140

    (92) new_array -> NEW type . array_expr_plus array_empty_star
    (93) array_expr_plus -> . array_expr array_expr_plus
    (94) array_expr_plus -> . array_expr
    (95) array_expr -> . LEFT_BRACKET expr RIGHT_BRACKET

    LEFT_BRACKET    shift and go to state 162

    array_expr_plus                shift and go to state 160
    array_expr                     shift and go to state 161

state 141

    (67) primary -> NEW ID . LEFT_PAR arguments_opt RIGHT_PAR
    (25) type -> ID .

    LEFT_PAR        shift and go to state 147
    LEFT_BRACKET    reduce using rule 25 (type -> ID .)


state 142

    (48) stmt -> RETURN expr_opt SEMICOLON .

    IF              reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    WHILE           reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    FOR             reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    RETURN          reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    BREAK           reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    CONTINUE        reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    SEMICOLON       reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    LEFT_BRACE      reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    PLUS_PLUS       reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    MINUS_MINUS     reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    INT             reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    FLOAT           reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    BOOLEAN         reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    ID              reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    THIS            reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    SUPER           reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    LEFT_PAR        reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    NEW             reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    INT_CONST       reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    FLOAT_CONST     reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    STRING_CONST    reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    NULL            reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    TRUE            reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    FALSE           reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    RIGHT_BRACE     reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)
    ELSE            reduce using rule 48 (stmt -> RETURN expr_opt SEMICOLON .)


state 143

    (84) expr -> expr ARITH_OP . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 163
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 144

    (85) expr -> expr BOOL_OP . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 164
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 145

    (86) expr -> UNARY_OP expr .
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for BOOL_OP resolved as shift
    RIGHT_BRACKET   reduce using rule 86 (expr -> UNARY_OP expr .)
    SEMICOLON       reduce using rule 86 (expr -> UNARY_OP expr .)
    RIGHT_PAR       reduce using rule 86 (expr -> UNARY_OP expr .)
    COMMA           reduce using rule 86 (expr -> UNARY_OP expr .)
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144

  ! ARITH_OP        [ reduce using rule 86 (expr -> UNARY_OP expr .) ]
  ! BOOL_OP         [ reduce using rule 86 (expr -> UNARY_OP expr .) ]


state 146

    (46) stmt -> WHILE LEFT_PAR expr . RIGHT_PAR stmt
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

    RIGHT_PAR       shift and go to state 165
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144


state 147

    (67) primary -> NEW ID LEFT_PAR . arguments_opt RIGHT_PAR
    (70) arguments_opt -> . empty
    (71) arguments_opt -> . arguments
    (2) empty -> .
    (72) arguments -> . expr more_expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    RIGHT_PAR       reduce using rule 2 (empty -> .)
    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 151
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    arguments                      shift and go to state 148
    arguments_opt                  shift and go to state 166
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121
    empty                          shift and go to state 149

state 148

    (71) arguments_opt -> arguments .

    RIGHT_PAR       reduce using rule 71 (arguments_opt -> arguments .)


state 149

    (70) arguments_opt -> empty .

    RIGHT_PAR       reduce using rule 70 (arguments_opt -> empty .)


state 150

    (80) method_invocation -> field_access LEFT_PAR arguments_opt . RIGHT_PAR

    RIGHT_PAR       shift and go to state 167


state 151

    (72) arguments -> expr . more_expr
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr
    (73) more_expr -> . empty
    (74) more_expr -> . COMMA expr more_expr
    (2) empty -> .

    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144
    COMMA           shift and go to state 168
    RIGHT_PAR       reduce using rule 2 (empty -> .)

    empty                          shift and go to state 170
    more_expr                      shift and go to state 169

state 152

    (102) stmt_expr_opt -> stmt_expr .

    SEMICOLON       reduce using rule 102 (stmt_expr_opt -> stmt_expr .)
    RIGHT_PAR       reduce using rule 102 (stmt_expr_opt -> stmt_expr .)


state 153

    (47) stmt -> FOR LEFT_PAR stmt_expr_opt . SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt

    SEMICOLON       shift and go to state 171


state 154

    (101) stmt_expr_opt -> empty .

    SEMICOLON       reduce using rule 101 (stmt_expr_opt -> empty .)
    RIGHT_PAR       reduce using rule 101 (stmt_expr_opt -> empty .)


state 155

    (79) array_access -> primary LEFT_BRACKET expr . RIGHT_BRACKET
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

    RIGHT_BRACKET   shift and go to state 172
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144


state 156

    (77) field_access -> primary DOT ID .

    LEFT_PAR        reduce using rule 77 (field_access -> primary DOT ID .)
    EQUALS          reduce using rule 77 (field_access -> primary DOT ID .)
    PLUS_PLUS       reduce using rule 77 (field_access -> primary DOT ID .)
    MINUS_MINUS     reduce using rule 77 (field_access -> primary DOT ID .)
    DOT             reduce using rule 77 (field_access -> primary DOT ID .)
    LEFT_BRACKET    reduce using rule 77 (field_access -> primary DOT ID .)
    RIGHT_PAR       reduce using rule 77 (field_access -> primary DOT ID .)
    ARITH_OP        reduce using rule 77 (field_access -> primary DOT ID .)
    BOOL_OP         reduce using rule 77 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 77 (field_access -> primary DOT ID .)
    RIGHT_BRACKET   reduce using rule 77 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 77 (field_access -> primary DOT ID .)


state 157

    (45) stmt -> IF LEFT_PAR expr . RIGHT_PAR stmt else_opt
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

    RIGHT_PAR       shift and go to state 173
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144


state 158

    (87) assign -> lhs EQUALS expr .
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for BOOL_OP resolved as shift
    COMMA           reduce using rule 87 (assign -> lhs EQUALS expr .)
    RIGHT_PAR       reduce using rule 87 (assign -> lhs EQUALS expr .)
    SEMICOLON       reduce using rule 87 (assign -> lhs EQUALS expr .)
    RIGHT_BRACKET   reduce using rule 87 (assign -> lhs EQUALS expr .)
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144

  ! ARITH_OP        [ reduce using rule 87 (assign -> lhs EQUALS expr .) ]
  ! BOOL_OP         [ reduce using rule 87 (assign -> lhs EQUALS expr .) ]


state 159

    (66) primary -> LEFT_PAR expr RIGHT_PAR .

    DOT             reduce using rule 66 (primary -> LEFT_PAR expr RIGHT_PAR .)
    LEFT_BRACKET    reduce using rule 66 (primary -> LEFT_PAR expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 66 (primary -> LEFT_PAR expr RIGHT_PAR .)
    ARITH_OP        reduce using rule 66 (primary -> LEFT_PAR expr RIGHT_PAR .)
    BOOL_OP         reduce using rule 66 (primary -> LEFT_PAR expr RIGHT_PAR .)
    RIGHT_BRACKET   reduce using rule 66 (primary -> LEFT_PAR expr RIGHT_PAR .)
    COMMA           reduce using rule 66 (primary -> LEFT_PAR expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 66 (primary -> LEFT_PAR expr RIGHT_PAR .)


state 160

    (92) new_array -> NEW type array_expr_plus . array_empty_star
    (96) array_empty_star -> . empty
    (97) array_empty_star -> . array_empty array_empty_star
    (2) empty -> .
    (98) array_empty -> . LEFT_BRACKET RIGHT_BRACKET

    ARITH_OP        reduce using rule 2 (empty -> .)
    BOOL_OP         reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    RIGHT_PAR       reduce using rule 2 (empty -> .)
    COMMA           reduce using rule 2 (empty -> .)
    RIGHT_BRACKET   reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 176

    array_empty_star               shift and go to state 174
    array_empty                    shift and go to state 175
    empty                          shift and go to state 177

state 161

    (93) array_expr_plus -> array_expr . array_expr_plus
    (94) array_expr_plus -> array_expr .
    (93) array_expr_plus -> . array_expr array_expr_plus
    (94) array_expr_plus -> . array_expr
    (95) array_expr -> . LEFT_BRACKET expr RIGHT_BRACKET

  ! shift/reduce conflict for LEFT_BRACKET resolved as shift
    ARITH_OP        reduce using rule 94 (array_expr_plus -> array_expr .)
    BOOL_OP         reduce using rule 94 (array_expr_plus -> array_expr .)
    SEMICOLON       reduce using rule 94 (array_expr_plus -> array_expr .)
    RIGHT_PAR       reduce using rule 94 (array_expr_plus -> array_expr .)
    COMMA           reduce using rule 94 (array_expr_plus -> array_expr .)
    RIGHT_BRACKET   reduce using rule 94 (array_expr_plus -> array_expr .)
    LEFT_BRACKET    shift and go to state 162

  ! LEFT_BRACKET    [ reduce using rule 94 (array_expr_plus -> array_expr .) ]

    array_expr                     shift and go to state 161
    array_expr_plus                shift and go to state 178

state 162

    (95) array_expr -> LEFT_BRACKET . expr RIGHT_BRACKET
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 179
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 163

    (84) expr -> expr ARITH_OP expr .
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for BOOL_OP resolved as shift
    RIGHT_BRACKET   reduce using rule 84 (expr -> expr ARITH_OP expr .)
    SEMICOLON       reduce using rule 84 (expr -> expr ARITH_OP expr .)
    RIGHT_PAR       reduce using rule 84 (expr -> expr ARITH_OP expr .)
    COMMA           reduce using rule 84 (expr -> expr ARITH_OP expr .)
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144

  ! ARITH_OP        [ reduce using rule 84 (expr -> expr ARITH_OP expr .) ]
  ! BOOL_OP         [ reduce using rule 84 (expr -> expr ARITH_OP expr .) ]


state 164

    (85) expr -> expr BOOL_OP expr .
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for BOOL_OP resolved as shift
    RIGHT_BRACKET   reduce using rule 85 (expr -> expr BOOL_OP expr .)
    SEMICOLON       reduce using rule 85 (expr -> expr BOOL_OP expr .)
    RIGHT_PAR       reduce using rule 85 (expr -> expr BOOL_OP expr .)
    COMMA           reduce using rule 85 (expr -> expr BOOL_OP expr .)
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144

  ! ARITH_OP        [ reduce using rule 85 (expr -> expr BOOL_OP expr .) ]
  ! BOOL_OP         [ reduce using rule 85 (expr -> expr BOOL_OP expr .) ]


state 165

    (46) stmt -> WHILE LEFT_PAR expr RIGHT_PAR . stmt
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt else_opt
    (46) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (47) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (48) stmt -> . RETURN expr_opt SEMICOLON
    (49) stmt -> . stmt_expr SEMICOLON
    (50) stmt -> . BREAK SEMICOLON
    (51) stmt -> . CONTINUE SEMICOLON
    (52) stmt -> . block
    (53) stmt -> . var_decl
    (54) stmt -> . SEMICOLON
    (99) stmt_expr -> . assign
    (100) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (21) var_decl -> . type variables SEMICOLON
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    IF              shift and go to state 96
    WHILE           shift and go to state 77
    FOR             shift and go to state 91
    RETURN          shift and go to state 76
    BREAK           shift and go to state 99
    CONTINUE        shift and go to state 101
    SEMICOLON       shift and go to state 83
    LEFT_BRACE      shift and go to state 72
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 95
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 90
    array_access                   shift and go to state 80
    stmt_expr                      shift and go to state 85
    primary                        shift and go to state 93
    stmt                           shift and go to state 180
    literal                        shift and go to state 86
    lhs                            shift and go to state 102
    var_decl                       shift and go to state 98
    type                           shift and go to state 88
    method_invocation              shift and go to state 87
    assign                         shift and go to state 107
    block                          shift and go to state 108

state 166

    (67) primary -> NEW ID LEFT_PAR arguments_opt . RIGHT_PAR

    RIGHT_PAR       shift and go to state 181


state 167

    (80) method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .

    DOT             reduce using rule 80 (method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .)
    LEFT_BRACKET    reduce using rule 80 (method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .)
    RIGHT_BRACKET   reduce using rule 80 (method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .)
    ARITH_OP        reduce using rule 80 (method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .)
    BOOL_OP         reduce using rule 80 (method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .)
    SEMICOLON       reduce using rule 80 (method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 80 (method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .)
    COMMA           reduce using rule 80 (method_invocation -> field_access LEFT_PAR arguments_opt RIGHT_PAR .)


state 168

    (74) more_expr -> COMMA . expr more_expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    field_access                   shift and go to state 116
    expr                           shift and go to state 182
    primary                        shift and go to state 111
    array_access                   shift and go to state 80
    literal                        shift and go to state 86
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121

state 169

    (72) arguments -> expr more_expr .

    RIGHT_PAR       reduce using rule 72 (arguments -> expr more_expr .)


state 170

    (73) more_expr -> empty .

    RIGHT_PAR       reduce using rule 73 (more_expr -> empty .)


state 171

    (47) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON . expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (103) expr_opt -> . empty
    (104) expr_opt -> . expr
    (2) empty -> .
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . new_array
    (84) expr -> . expr ARITH_OP expr
    (85) expr -> . expr BOOL_OP expr
    (86) expr -> . UNARY_OP expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (92) new_array -> . NEW type array_expr_plus array_empty_star
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET

    SEMICOLON       reduce using rule 2 (empty -> .)
    UNARY_OP        shift and go to state 120
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 112
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97
    ID              shift and go to state 117

    new_array                      shift and go to state 110
    array_access                   shift and go to state 80
    field_access                   shift and go to state 116
    expr                           shift and go to state 118
    primary                        shift and go to state 111
    literal                        shift and go to state 86
    expr_opt                       shift and go to state 183
    lhs                            shift and go to state 119
    method_invocation              shift and go to state 114
    assign                         shift and go to state 121
    empty                          shift and go to state 115

state 172

    (79) array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .

    EQUALS          reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    PLUS_PLUS       reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    MINUS_MINUS     reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    DOT             reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    LEFT_BRACKET    reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    ARITH_OP        reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    BOOL_OP         reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    COMMA           reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_PAR       reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 79 (array_access -> primary LEFT_BRACKET expr RIGHT_BRACKET .)


state 173

    (45) stmt -> IF LEFT_PAR expr RIGHT_PAR . stmt else_opt
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt else_opt
    (46) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (47) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (48) stmt -> . RETURN expr_opt SEMICOLON
    (49) stmt -> . stmt_expr SEMICOLON
    (50) stmt -> . BREAK SEMICOLON
    (51) stmt -> . CONTINUE SEMICOLON
    (52) stmt -> . block
    (53) stmt -> . var_decl
    (54) stmt -> . SEMICOLON
    (99) stmt_expr -> . assign
    (100) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (21) var_decl -> . type variables SEMICOLON
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    IF              shift and go to state 96
    WHILE           shift and go to state 77
    FOR             shift and go to state 91
    RETURN          shift and go to state 76
    BREAK           shift and go to state 99
    CONTINUE        shift and go to state 101
    SEMICOLON       shift and go to state 83
    LEFT_BRACE      shift and go to state 72
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 95
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 90
    array_access                   shift and go to state 80
    stmt_expr                      shift and go to state 85
    primary                        shift and go to state 93
    stmt                           shift and go to state 184
    literal                        shift and go to state 86
    lhs                            shift and go to state 102
    var_decl                       shift and go to state 98
    type                           shift and go to state 88
    method_invocation              shift and go to state 87
    assign                         shift and go to state 107
    block                          shift and go to state 108

state 174

    (92) new_array -> NEW type array_expr_plus array_empty_star .

    ARITH_OP        reduce using rule 92 (new_array -> NEW type array_expr_plus array_empty_star .)
    BOOL_OP         reduce using rule 92 (new_array -> NEW type array_expr_plus array_empty_star .)
    COMMA           reduce using rule 92 (new_array -> NEW type array_expr_plus array_empty_star .)
    RIGHT_PAR       reduce using rule 92 (new_array -> NEW type array_expr_plus array_empty_star .)
    SEMICOLON       reduce using rule 92 (new_array -> NEW type array_expr_plus array_empty_star .)
    RIGHT_BRACKET   reduce using rule 92 (new_array -> NEW type array_expr_plus array_empty_star .)


state 175

    (97) array_empty_star -> array_empty . array_empty_star
    (96) array_empty_star -> . empty
    (97) array_empty_star -> . array_empty array_empty_star
    (2) empty -> .
    (98) array_empty -> . LEFT_BRACKET RIGHT_BRACKET

    ARITH_OP        reduce using rule 2 (empty -> .)
    BOOL_OP         reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    RIGHT_PAR       reduce using rule 2 (empty -> .)
    COMMA           reduce using rule 2 (empty -> .)
    RIGHT_BRACKET   reduce using rule 2 (empty -> .)
    LEFT_BRACKET    shift and go to state 176

    array_empty                    shift and go to state 175
    array_empty_star               shift and go to state 185
    empty                          shift and go to state 177

state 176

    (98) array_empty -> LEFT_BRACKET . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 186


state 177

    (96) array_empty_star -> empty .

    ARITH_OP        reduce using rule 96 (array_empty_star -> empty .)
    BOOL_OP         reduce using rule 96 (array_empty_star -> empty .)
    SEMICOLON       reduce using rule 96 (array_empty_star -> empty .)
    RIGHT_PAR       reduce using rule 96 (array_empty_star -> empty .)
    COMMA           reduce using rule 96 (array_empty_star -> empty .)
    RIGHT_BRACKET   reduce using rule 96 (array_empty_star -> empty .)


state 178

    (93) array_expr_plus -> array_expr array_expr_plus .

    LEFT_BRACKET    reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    ARITH_OP        reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    BOOL_OP         reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    SEMICOLON       reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    RIGHT_PAR       reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    COMMA           reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)
    RIGHT_BRACKET   reduce using rule 93 (array_expr_plus -> array_expr array_expr_plus .)


state 179

    (95) array_expr -> LEFT_BRACKET expr . RIGHT_BRACKET
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr

    RIGHT_BRACKET   shift and go to state 187
    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144


state 180

    (46) stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .

    IF              reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    WHILE           reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    FOR             reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    RETURN          reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    BREAK           reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    CONTINUE        reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    SEMICOLON       reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    LEFT_BRACE      reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    PLUS_PLUS       reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    MINUS_MINUS     reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    INT             reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    FLOAT           reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    BOOLEAN         reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    ID              reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    THIS            reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    SUPER           reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    LEFT_PAR        reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    NEW             reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    INT_CONST       reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    FLOAT_CONST     reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    STRING_CONST    reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    NULL            reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    TRUE            reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    FALSE           reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    RIGHT_BRACE     reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)
    ELSE            reduce using rule 46 (stmt -> WHILE LEFT_PAR expr RIGHT_PAR stmt .)


state 181

    (67) primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .

    DOT             reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .)
    LEFT_BRACKET    reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .)
    ARITH_OP        reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .)
    BOOL_OP         reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .)
    RIGHT_BRACKET   reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .)
    COMMA           reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .)
    SEMICOLON       reduce using rule 67 (primary -> NEW ID LEFT_PAR arguments_opt RIGHT_PAR .)


state 182

    (74) more_expr -> COMMA expr . more_expr
    (84) expr -> expr . ARITH_OP expr
    (85) expr -> expr . BOOL_OP expr
    (73) more_expr -> . empty
    (74) more_expr -> . COMMA expr more_expr
    (2) empty -> .

    ARITH_OP        shift and go to state 143
    BOOL_OP         shift and go to state 144
    COMMA           shift and go to state 168
    RIGHT_PAR       reduce using rule 2 (empty -> .)

    empty                          shift and go to state 170
    more_expr                      shift and go to state 188

state 183

    (47) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt . SEMICOLON stmt_expr_opt RIGHT_PAR stmt

    SEMICOLON       shift and go to state 189


state 184

    (45) stmt -> IF LEFT_PAR expr RIGHT_PAR stmt . else_opt
    (55) else_opt -> . empty
    (56) else_opt -> . ELSE stmt
    (2) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 190
    IF              reduce using rule 2 (empty -> .)
    WHILE           reduce using rule 2 (empty -> .)
    FOR             reduce using rule 2 (empty -> .)
    RETURN          reduce using rule 2 (empty -> .)
    BREAK           reduce using rule 2 (empty -> .)
    CONTINUE        reduce using rule 2 (empty -> .)
    SEMICOLON       reduce using rule 2 (empty -> .)
    LEFT_BRACE      reduce using rule 2 (empty -> .)
    PLUS_PLUS       reduce using rule 2 (empty -> .)
    MINUS_MINUS     reduce using rule 2 (empty -> .)
    INT             reduce using rule 2 (empty -> .)
    FLOAT           reduce using rule 2 (empty -> .)
    BOOLEAN         reduce using rule 2 (empty -> .)
    ID              reduce using rule 2 (empty -> .)
    THIS            reduce using rule 2 (empty -> .)
    SUPER           reduce using rule 2 (empty -> .)
    LEFT_PAR        reduce using rule 2 (empty -> .)
    NEW             reduce using rule 2 (empty -> .)
    INT_CONST       reduce using rule 2 (empty -> .)
    FLOAT_CONST     reduce using rule 2 (empty -> .)
    STRING_CONST    reduce using rule 2 (empty -> .)
    NULL            reduce using rule 2 (empty -> .)
    TRUE            reduce using rule 2 (empty -> .)
    FALSE           reduce using rule 2 (empty -> .)
    RIGHT_BRACE     reduce using rule 2 (empty -> .)

  ! ELSE            [ reduce using rule 2 (empty -> .) ]

    empty                          shift and go to state 192
    else_opt                       shift and go to state 191

state 185

    (97) array_empty_star -> array_empty array_empty_star .

    ARITH_OP        reduce using rule 97 (array_empty_star -> array_empty array_empty_star .)
    BOOL_OP         reduce using rule 97 (array_empty_star -> array_empty array_empty_star .)
    SEMICOLON       reduce using rule 97 (array_empty_star -> array_empty array_empty_star .)
    RIGHT_PAR       reduce using rule 97 (array_empty_star -> array_empty array_empty_star .)
    COMMA           reduce using rule 97 (array_empty_star -> array_empty array_empty_star .)
    RIGHT_BRACKET   reduce using rule 97 (array_empty_star -> array_empty array_empty_star .)


state 186

    (98) array_empty -> LEFT_BRACKET RIGHT_BRACKET .

    LEFT_BRACKET    reduce using rule 98 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    ARITH_OP        reduce using rule 98 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    BOOL_OP         reduce using rule 98 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 98 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    RIGHT_PAR       reduce using rule 98 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    COMMA           reduce using rule 98 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 98 (array_empty -> LEFT_BRACKET RIGHT_BRACKET .)


state 187

    (95) array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .

    LEFT_BRACKET    reduce using rule 95 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    ARITH_OP        reduce using rule 95 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    BOOL_OP         reduce using rule 95 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 95 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_PAR       reduce using rule 95 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    COMMA           reduce using rule 95 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 95 (array_expr -> LEFT_BRACKET expr RIGHT_BRACKET .)


state 188

    (74) more_expr -> COMMA expr more_expr .

    RIGHT_PAR       reduce using rule 74 (more_expr -> COMMA expr more_expr .)


state 189

    (47) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON . stmt_expr_opt RIGHT_PAR stmt
    (101) stmt_expr_opt -> . empty
    (102) stmt_expr_opt -> . stmt_expr
    (2) empty -> .
    (99) stmt_expr -> . assign
    (100) stmt_expr -> . method_invocation
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    RIGHT_PAR       reduce using rule 2 (empty -> .)
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    ID              shift and go to state 117
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 90
    primary                        shift and go to state 93
    stmt_expr_opt                  shift and go to state 193
    stmt_expr                      shift and go to state 152
    literal                        shift and go to state 86
    lhs                            shift and go to state 102
    method_invocation              shift and go to state 87
    array_access                   shift and go to state 80
    assign                         shift and go to state 107
    empty                          shift and go to state 154

state 190

    (56) else_opt -> ELSE . stmt
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt else_opt
    (46) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (47) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (48) stmt -> . RETURN expr_opt SEMICOLON
    (49) stmt -> . stmt_expr SEMICOLON
    (50) stmt -> . BREAK SEMICOLON
    (51) stmt -> . CONTINUE SEMICOLON
    (52) stmt -> . block
    (53) stmt -> . var_decl
    (54) stmt -> . SEMICOLON
    (99) stmt_expr -> . assign
    (100) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (21) var_decl -> . type variables SEMICOLON
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    IF              shift and go to state 96
    WHILE           shift and go to state 77
    FOR             shift and go to state 91
    RETURN          shift and go to state 76
    BREAK           shift and go to state 99
    CONTINUE        shift and go to state 101
    SEMICOLON       shift and go to state 83
    LEFT_BRACE      shift and go to state 72
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 95
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 90
    array_access                   shift and go to state 80
    stmt_expr                      shift and go to state 85
    primary                        shift and go to state 93
    stmt                           shift and go to state 194
    literal                        shift and go to state 86
    lhs                            shift and go to state 102
    var_decl                       shift and go to state 98
    type                           shift and go to state 88
    method_invocation              shift and go to state 87
    assign                         shift and go to state 107
    block                          shift and go to state 108

state 191

    (45) stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .

    IF              reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    WHILE           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    FOR             reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    RETURN          reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    BREAK           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    CONTINUE        reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    SEMICOLON       reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    LEFT_BRACE      reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    PLUS_PLUS       reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    MINUS_MINUS     reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    INT             reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    FLOAT           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    BOOLEAN         reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    ID              reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    THIS            reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    SUPER           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    LEFT_PAR        reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    NEW             reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    INT_CONST       reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    FLOAT_CONST     reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    STRING_CONST    reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    NULL            reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    TRUE            reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    FALSE           reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    RIGHT_BRACE     reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)
    ELSE            reduce using rule 45 (stmt -> IF LEFT_PAR expr RIGHT_PAR stmt else_opt .)


state 192

    (55) else_opt -> empty .

    IF              reduce using rule 55 (else_opt -> empty .)
    WHILE           reduce using rule 55 (else_opt -> empty .)
    FOR             reduce using rule 55 (else_opt -> empty .)
    RETURN          reduce using rule 55 (else_opt -> empty .)
    BREAK           reduce using rule 55 (else_opt -> empty .)
    CONTINUE        reduce using rule 55 (else_opt -> empty .)
    SEMICOLON       reduce using rule 55 (else_opt -> empty .)
    LEFT_BRACE      reduce using rule 55 (else_opt -> empty .)
    PLUS_PLUS       reduce using rule 55 (else_opt -> empty .)
    MINUS_MINUS     reduce using rule 55 (else_opt -> empty .)
    INT             reduce using rule 55 (else_opt -> empty .)
    FLOAT           reduce using rule 55 (else_opt -> empty .)
    BOOLEAN         reduce using rule 55 (else_opt -> empty .)
    ID              reduce using rule 55 (else_opt -> empty .)
    THIS            reduce using rule 55 (else_opt -> empty .)
    SUPER           reduce using rule 55 (else_opt -> empty .)
    LEFT_PAR        reduce using rule 55 (else_opt -> empty .)
    NEW             reduce using rule 55 (else_opt -> empty .)
    INT_CONST       reduce using rule 55 (else_opt -> empty .)
    FLOAT_CONST     reduce using rule 55 (else_opt -> empty .)
    STRING_CONST    reduce using rule 55 (else_opt -> empty .)
    NULL            reduce using rule 55 (else_opt -> empty .)
    TRUE            reduce using rule 55 (else_opt -> empty .)
    FALSE           reduce using rule 55 (else_opt -> empty .)
    RIGHT_BRACE     reduce using rule 55 (else_opt -> empty .)
    ELSE            reduce using rule 55 (else_opt -> empty .)


state 193

    (47) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt . RIGHT_PAR stmt

    RIGHT_PAR       shift and go to state 195


state 194

    (56) else_opt -> ELSE stmt .

    IF              reduce using rule 56 (else_opt -> ELSE stmt .)
    WHILE           reduce using rule 56 (else_opt -> ELSE stmt .)
    FOR             reduce using rule 56 (else_opt -> ELSE stmt .)
    RETURN          reduce using rule 56 (else_opt -> ELSE stmt .)
    BREAK           reduce using rule 56 (else_opt -> ELSE stmt .)
    CONTINUE        reduce using rule 56 (else_opt -> ELSE stmt .)
    SEMICOLON       reduce using rule 56 (else_opt -> ELSE stmt .)
    LEFT_BRACE      reduce using rule 56 (else_opt -> ELSE stmt .)
    PLUS_PLUS       reduce using rule 56 (else_opt -> ELSE stmt .)
    MINUS_MINUS     reduce using rule 56 (else_opt -> ELSE stmt .)
    INT             reduce using rule 56 (else_opt -> ELSE stmt .)
    FLOAT           reduce using rule 56 (else_opt -> ELSE stmt .)
    BOOLEAN         reduce using rule 56 (else_opt -> ELSE stmt .)
    ID              reduce using rule 56 (else_opt -> ELSE stmt .)
    THIS            reduce using rule 56 (else_opt -> ELSE stmt .)
    SUPER           reduce using rule 56 (else_opt -> ELSE stmt .)
    LEFT_PAR        reduce using rule 56 (else_opt -> ELSE stmt .)
    NEW             reduce using rule 56 (else_opt -> ELSE stmt .)
    INT_CONST       reduce using rule 56 (else_opt -> ELSE stmt .)
    FLOAT_CONST     reduce using rule 56 (else_opt -> ELSE stmt .)
    STRING_CONST    reduce using rule 56 (else_opt -> ELSE stmt .)
    NULL            reduce using rule 56 (else_opt -> ELSE stmt .)
    TRUE            reduce using rule 56 (else_opt -> ELSE stmt .)
    FALSE           reduce using rule 56 (else_opt -> ELSE stmt .)
    RIGHT_BRACE     reduce using rule 56 (else_opt -> ELSE stmt .)
    ELSE            reduce using rule 56 (else_opt -> ELSE stmt .)


state 195

    (47) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR . stmt
    (45) stmt -> . IF LEFT_PAR expr RIGHT_PAR stmt else_opt
    (46) stmt -> . WHILE LEFT_PAR expr RIGHT_PAR stmt
    (47) stmt -> . FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt
    (48) stmt -> . RETURN expr_opt SEMICOLON
    (49) stmt -> . stmt_expr SEMICOLON
    (50) stmt -> . BREAK SEMICOLON
    (51) stmt -> . CONTINUE SEMICOLON
    (52) stmt -> . block
    (53) stmt -> . var_decl
    (54) stmt -> . SEMICOLON
    (99) stmt_expr -> . assign
    (100) stmt_expr -> . method_invocation
    (42) block -> . LEFT_BRACE stmt_star RIGHT_BRACE
    (21) var_decl -> . type variables SEMICOLON
    (87) assign -> . lhs EQUALS expr
    (88) assign -> . lhs PLUS_PLUS
    (89) assign -> . PLUS_PLUS lhs
    (90) assign -> . lhs MINUS_MINUS
    (91) assign -> . MINUS_MINUS lhs
    (80) method_invocation -> . field_access LEFT_PAR arguments_opt RIGHT_PAR
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . ID
    (75) lhs -> . field_access
    (76) lhs -> . array_access
    (77) field_access -> . primary DOT ID
    (78) field_access -> . ID
    (79) array_access -> . primary LEFT_BRACKET expr RIGHT_BRACKET
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LEFT_PAR expr RIGHT_PAR
    (67) primary -> . NEW ID LEFT_PAR arguments_opt RIGHT_PAR
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    IF              shift and go to state 96
    WHILE           shift and go to state 77
    FOR             shift and go to state 91
    RETURN          shift and go to state 76
    BREAK           shift and go to state 99
    CONTINUE        shift and go to state 101
    SEMICOLON       shift and go to state 83
    LEFT_BRACE      shift and go to state 72
    PLUS_PLUS       shift and go to state 104
    MINUS_MINUS     shift and go to state 103
    INT             shift and go to state 28
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 95
    THIS            shift and go to state 100
    SUPER           shift and go to state 106
    LEFT_PAR        shift and go to state 105
    NEW             shift and go to state 78
    INT_CONST       shift and go to state 82
    FLOAT_CONST     shift and go to state 109
    STRING_CONST    shift and go to state 81
    NULL            shift and go to state 79
    TRUE            shift and go to state 84
    FALSE           shift and go to state 97

    field_access                   shift and go to state 90
    array_access                   shift and go to state 80
    stmt_expr                      shift and go to state 85
    primary                        shift and go to state 93
    stmt                           shift and go to state 196
    literal                        shift and go to state 86
    lhs                            shift and go to state 102
    var_decl                       shift and go to state 98
    type                           shift and go to state 88
    method_invocation              shift and go to state 87
    assign                         shift and go to state 107
    block                          shift and go to state 108

state 196

    (47) stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .

    IF              reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    WHILE           reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    FOR             reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    RETURN          reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    BREAK           reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    CONTINUE        reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    SEMICOLON       reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    LEFT_BRACE      reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    PLUS_PLUS       reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    MINUS_MINUS     reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    INT             reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    FLOAT           reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    BOOLEAN         reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    ID              reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    THIS            reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    SUPER           reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    LEFT_PAR        reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    NEW             reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    INT_CONST       reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    FLOAT_CONST     reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    STRING_CONST    reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    NULL            reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    TRUE            reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    FALSE           reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    RIGHT_BRACE     reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)
    ELSE            reduce using rule 47 (stmt -> FOR LEFT_PAR stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RIGHT_PAR stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ARITH_OP in state 145 resolved as shift
WARNING: shift/reduce conflict for BOOL_OP in state 145 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 158 resolved as shift
WARNING: shift/reduce conflict for BOOL_OP in state 158 resolved as shift
WARNING: shift/reduce conflict for LEFT_BRACKET in state 161 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for BOOL_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for BOOL_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 184 resolved as shift
