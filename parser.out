Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    ARITH_OP
    DO
    RETURN
    NUMBER
    WHILE
    NEW
    BOOL_OP
    CONTINUE
    CLASS
    FOR
    EQUALS
    ELSE
    EXTENDS
    RIGHT_PAR
    IF
    BREAK
    UNARY_OP
    LEFT_PAR

Grammar

Rule 0     S' -> start
Rule 1     start -> method_decl
Rule 2     start -> constructor_decl
Rule 3     start -> field_decl
Rule 4     start -> literal
Rule 5     start -> field_access
Rule 6     field_decl -> modifier var_decl
Rule 7     modifier -> <empty>
Rule 8     modifier -> PUBLIC
Rule 9     modifier -> PUBLIC STATIC
Rule 10    modifier -> PRIVATE
Rule 11    modifier -> PRIVATE STATIC
Rule 12    modifier -> STATIC
Rule 13    var_decl -> type variables SEMICOLON
Rule 14    type -> INT
Rule 15    type -> FLOAT
Rule 16    type -> BOOLEAN
Rule 17    variables -> variable variable2
Rule 18    variable2 -> <empty>
Rule 19    variable2 -> COMMA variable variable2
Rule 20    variable -> ID
Rule 21    method_decl -> modifier type ID
Rule 22    method_decl -> modifier type ID formals
Rule 23    method_decl -> modifier VOID ID
Rule 24    method_decl -> modifier VOID ID formals
Rule 25    constructor_decl -> modifier ID
Rule 26    constructor_decl -> modifier ID formals
Rule 27    formals -> formal_param formal_param2
Rule 28    formal_param2 -> <empty>
Rule 29    formal_param2 -> COMMA formal_param formal_param2
Rule 30    formal_param -> type variable
Rule 31    literal -> STRING_CONST
Rule 32    literal -> NULL
Rule 33    literal -> TRUE
Rule 34    literal -> FALSE
Rule 35    primary -> literal
Rule 36    primary -> THIS
Rule 37    primary -> SUPER
Rule 38    field_access -> primary DOT ID
Rule 39    field_access -> ID

Terminals, with rules where they appear

ARITH_OP             : 
BOOLEAN              : 16
BOOL_OP              : 
BREAK                : 
CLASS                : 
COMMA                : 19 29
CONTINUE             : 
DO                   : 
DOT                  : 38
ELSE                 : 
EQUALS               : 
EXTENDS              : 
FALSE                : 34
FLOAT                : 15
FOR                  : 
ID                   : 20 21 22 23 24 25 26 38 39
IF                   : 
INT                  : 14
LEFT_PAR             : 
NEW                  : 
NULL                 : 32
NUMBER               : 
PRIVATE              : 10 11
PUBLIC               : 8 9
RETURN               : 
RIGHT_PAR            : 
SEMICOLON            : 13
STATIC               : 9 11 12
STRING_CONST         : 31
SUPER                : 37
THIS                 : 36
TRUE                 : 33
UNARY_OP             : 
VOID                 : 23 24
WHILE                : 
error                : 

Nonterminals, with rules where they appear

constructor_decl     : 2
field_access         : 5
field_decl           : 3
formal_param         : 27 29
formal_param2        : 27 29
formals              : 22 24 26
literal              : 4 35
method_decl          : 1
modifier             : 6 21 22 23 24 25 26
primary              : 38
start                : 0
type                 : 13 21 22 30
var_decl             : 6
variable             : 17 19 30
variable2            : 17 19
variables            : 13

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . method_decl
    (2) start -> . constructor_decl
    (3) start -> . field_decl
    (4) start -> . literal
    (5) start -> . field_access
    (21) method_decl -> . modifier type ID
    (22) method_decl -> . modifier type ID formals
    (23) method_decl -> . modifier VOID ID
    (24) method_decl -> . modifier VOID ID formals
    (25) constructor_decl -> . modifier ID
    (26) constructor_decl -> . modifier ID formals
    (6) field_decl -> . modifier var_decl
    (31) literal -> . STRING_CONST
    (32) literal -> . NULL
    (33) literal -> . TRUE
    (34) literal -> . FALSE
    (38) field_access -> . primary DOT ID
    (39) field_access -> . ID
    (7) modifier -> .
    (8) modifier -> . PUBLIC
    (9) modifier -> . PUBLIC STATIC
    (10) modifier -> . PRIVATE
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . STATIC
    (35) primary -> . literal
    (36) primary -> . THIS
    (37) primary -> . SUPER

  ! shift/reduce conflict for ID resolved as shift
    STRING_CONST    shift and go to state 6
    NULL            shift and go to state 4
    TRUE            shift and go to state 5
    FALSE           shift and go to state 12
    ID              shift and go to state 11
    VOID            reduce using rule 7 (modifier -> .)
    INT             reduce using rule 7 (modifier -> .)
    FLOAT           reduce using rule 7 (modifier -> .)
    BOOLEAN         reduce using rule 7 (modifier -> .)
    PUBLIC          shift and go to state 18
    PRIVATE         shift and go to state 7
    STATIC          shift and go to state 3
    THIS            shift and go to state 13
    SUPER           shift and go to state 17

  ! ID              [ reduce using rule 7 (modifier -> .) ]

    field_access                   shift and go to state 10
    field_decl                     shift and go to state 14
    constructor_decl               shift and go to state 1
    method_decl                    shift and go to state 15
    primary                        shift and go to state 2
    start                          shift and go to state 8
    literal                        shift and go to state 9
    modifier                       shift and go to state 16

state 1

    (2) start -> constructor_decl .

    $end            reduce using rule 2 (start -> constructor_decl .)


state 2

    (38) field_access -> primary . DOT ID

    DOT             shift and go to state 19


state 3

    (12) modifier -> STATIC .

    VOID            reduce using rule 12 (modifier -> STATIC .)
    ID              reduce using rule 12 (modifier -> STATIC .)
    INT             reduce using rule 12 (modifier -> STATIC .)
    FLOAT           reduce using rule 12 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 12 (modifier -> STATIC .)


state 4

    (32) literal -> NULL .

    $end            reduce using rule 32 (literal -> NULL .)
    DOT             reduce using rule 32 (literal -> NULL .)


state 5

    (33) literal -> TRUE .

    $end            reduce using rule 33 (literal -> TRUE .)
    DOT             reduce using rule 33 (literal -> TRUE .)


state 6

    (31) literal -> STRING_CONST .

    $end            reduce using rule 31 (literal -> STRING_CONST .)
    DOT             reduce using rule 31 (literal -> STRING_CONST .)


state 7

    (10) modifier -> PRIVATE .
    (11) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 10 (modifier -> PRIVATE .)
    ID              reduce using rule 10 (modifier -> PRIVATE .)
    INT             reduce using rule 10 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 10 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 10 (modifier -> PRIVATE .)
    STATIC          shift and go to state 20


state 8

    (0) S' -> start .



state 9

    (4) start -> literal .
    (35) primary -> literal .

    $end            reduce using rule 4 (start -> literal .)
    DOT             reduce using rule 35 (primary -> literal .)


state 10

    (5) start -> field_access .

    $end            reduce using rule 5 (start -> field_access .)


state 11

    (39) field_access -> ID .

    $end            reduce using rule 39 (field_access -> ID .)


state 12

    (34) literal -> FALSE .

    $end            reduce using rule 34 (literal -> FALSE .)
    DOT             reduce using rule 34 (literal -> FALSE .)


state 13

    (36) primary -> THIS .

    DOT             reduce using rule 36 (primary -> THIS .)


state 14

    (3) start -> field_decl .

    $end            reduce using rule 3 (start -> field_decl .)


state 15

    (1) start -> method_decl .

    $end            reduce using rule 1 (start -> method_decl .)


state 16

    (21) method_decl -> modifier . type ID
    (22) method_decl -> modifier . type ID formals
    (23) method_decl -> modifier . VOID ID
    (24) method_decl -> modifier . VOID ID formals
    (25) constructor_decl -> modifier . ID
    (26) constructor_decl -> modifier . ID formals
    (6) field_decl -> modifier . var_decl
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . BOOLEAN
    (13) var_decl -> . type variables SEMICOLON

    VOID            shift and go to state 22
    ID              shift and go to state 27
    INT             shift and go to state 21
    FLOAT           shift and go to state 23
    BOOLEAN         shift and go to state 25

    type                           shift and go to state 26
    var_decl                       shift and go to state 24

state 17

    (37) primary -> SUPER .

    DOT             reduce using rule 37 (primary -> SUPER .)


state 18

    (8) modifier -> PUBLIC .
    (9) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 8 (modifier -> PUBLIC .)
    ID              reduce using rule 8 (modifier -> PUBLIC .)
    INT             reduce using rule 8 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 8 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 8 (modifier -> PUBLIC .)
    STATIC          shift and go to state 28


state 19

    (38) field_access -> primary DOT . ID

    ID              shift and go to state 29


state 20

    (11) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 11 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 11 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 11 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 11 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 11 (modifier -> PRIVATE STATIC .)


state 21

    (14) type -> INT .

    ID              reduce using rule 14 (type -> INT .)


state 22

    (23) method_decl -> modifier VOID . ID
    (24) method_decl -> modifier VOID . ID formals

    ID              shift and go to state 30


state 23

    (15) type -> FLOAT .

    ID              reduce using rule 15 (type -> FLOAT .)


state 24

    (6) field_decl -> modifier var_decl .

    $end            reduce using rule 6 (field_decl -> modifier var_decl .)


state 25

    (16) type -> BOOLEAN .

    ID              reduce using rule 16 (type -> BOOLEAN .)


state 26

    (21) method_decl -> modifier type . ID
    (22) method_decl -> modifier type . ID formals
    (13) var_decl -> type . variables SEMICOLON
    (17) variables -> . variable variable2
    (20) variable -> . ID

    ID              shift and go to state 33

    variables                      shift and go to state 31
    variable                       shift and go to state 32

state 27

    (25) constructor_decl -> modifier ID .
    (26) constructor_decl -> modifier ID . formals
    (27) formals -> . formal_param formal_param2
    (30) formal_param -> . type variable
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . BOOLEAN

    $end            reduce using rule 25 (constructor_decl -> modifier ID .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 23
    BOOLEAN         shift and go to state 25

    formal_param                   shift and go to state 34
    type                           shift and go to state 35
    formals                        shift and go to state 36

state 28

    (9) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 9 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 9 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 9 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 9 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 9 (modifier -> PUBLIC STATIC .)


state 29

    (38) field_access -> primary DOT ID .

    $end            reduce using rule 38 (field_access -> primary DOT ID .)


state 30

    (23) method_decl -> modifier VOID ID .
    (24) method_decl -> modifier VOID ID . formals
    (27) formals -> . formal_param formal_param2
    (30) formal_param -> . type variable
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . BOOLEAN

    $end            reduce using rule 23 (method_decl -> modifier VOID ID .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 23
    BOOLEAN         shift and go to state 25

    formal_param                   shift and go to state 34
    type                           shift and go to state 35
    formals                        shift and go to state 37

state 31

    (13) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 38


state 32

    (17) variables -> variable . variable2
    (18) variable2 -> .
    (19) variable2 -> . COMMA variable variable2

    SEMICOLON       reduce using rule 18 (variable2 -> .)
    COMMA           shift and go to state 40

    variable2                      shift and go to state 39

state 33

    (21) method_decl -> modifier type ID .
    (22) method_decl -> modifier type ID . formals
    (20) variable -> ID .
    (27) formals -> . formal_param formal_param2
    (30) formal_param -> . type variable
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . BOOLEAN

    $end            reduce using rule 21 (method_decl -> modifier type ID .)
    COMMA           reduce using rule 20 (variable -> ID .)
    SEMICOLON       reduce using rule 20 (variable -> ID .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 23
    BOOLEAN         shift and go to state 25

    formal_param                   shift and go to state 34
    type                           shift and go to state 35
    formals                        shift and go to state 41

state 34

    (27) formals -> formal_param . formal_param2
    (28) formal_param2 -> .
    (29) formal_param2 -> . COMMA formal_param formal_param2

    $end            reduce using rule 28 (formal_param2 -> .)
    COMMA           shift and go to state 43

    formal_param2                  shift and go to state 42

state 35

    (30) formal_param -> type . variable
    (20) variable -> . ID

    ID              shift and go to state 45

    variable                       shift and go to state 44

state 36

    (26) constructor_decl -> modifier ID formals .

    $end            reduce using rule 26 (constructor_decl -> modifier ID formals .)


state 37

    (24) method_decl -> modifier VOID ID formals .

    $end            reduce using rule 24 (method_decl -> modifier VOID ID formals .)


state 38

    (13) var_decl -> type variables SEMICOLON .

    $end            reduce using rule 13 (var_decl -> type variables SEMICOLON .)


state 39

    (17) variables -> variable variable2 .

    SEMICOLON       reduce using rule 17 (variables -> variable variable2 .)


state 40

    (19) variable2 -> COMMA . variable variable2
    (20) variable -> . ID

    ID              shift and go to state 45

    variable                       shift and go to state 46

state 41

    (22) method_decl -> modifier type ID formals .

    $end            reduce using rule 22 (method_decl -> modifier type ID formals .)


state 42

    (27) formals -> formal_param formal_param2 .

    $end            reduce using rule 27 (formals -> formal_param formal_param2 .)


state 43

    (29) formal_param2 -> COMMA . formal_param formal_param2
    (30) formal_param -> . type variable
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . BOOLEAN

    INT             shift and go to state 21
    FLOAT           shift and go to state 23
    BOOLEAN         shift and go to state 25

    formal_param                   shift and go to state 47
    type                           shift and go to state 35

state 44

    (30) formal_param -> type variable .

    COMMA           reduce using rule 30 (formal_param -> type variable .)
    $end            reduce using rule 30 (formal_param -> type variable .)


state 45

    (20) variable -> ID .

    COMMA           reduce using rule 20 (variable -> ID .)
    $end            reduce using rule 20 (variable -> ID .)
    SEMICOLON       reduce using rule 20 (variable -> ID .)


state 46

    (19) variable2 -> COMMA variable . variable2
    (18) variable2 -> .
    (19) variable2 -> . COMMA variable variable2

    SEMICOLON       reduce using rule 18 (variable2 -> .)
    COMMA           shift and go to state 40

    variable2                      shift and go to state 48

state 47

    (29) formal_param2 -> COMMA formal_param . formal_param2
    (28) formal_param2 -> .
    (29) formal_param2 -> . COMMA formal_param formal_param2

    $end            reduce using rule 28 (formal_param2 -> .)
    COMMA           shift and go to state 43

    formal_param2                  shift and go to state 49

state 48

    (19) variable2 -> COMMA variable variable2 .

    SEMICOLON       reduce using rule 19 (variable2 -> COMMA variable variable2 .)


state 49

    (29) formal_param2 -> COMMA formal_param formal_param2 .

    $end            reduce using rule 29 (formal_param2 -> COMMA formal_param formal_param2 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
